<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sensor and Lock Mechanics Sandbox v4.2</title>
<!-- SMALL FIXES APPLIED: (1) Homogenized player detection logic, (2) Replaced sliders with number inputs, (3) Added custom ship profile creator with localStorage, (4) Pure black background + white grid + larger ship icons + 2x zoom-out, (5) Allie/Enemy tags with distinct colors, (6) Fixed incoming lock indicator layout, (7) Thicker sensor rings, (8) Spawn enemies 40km right with default headings, (9) Export/import full state JSON, (10) Perf test spawns 19 allies + 20 enemies, (11) HUD alignment for larger icons -->
<style>
:root {
--bg-color: #000000; /* SMALL FIX #4: pure black background */
--panel-bg: #161b22;
--text-main: #c9d1d9;
--text-dim: #8b949e;
--accent: #58a6ff;
--danger: #f85149;
--warning: #d29922;
--success: #3fb950;
--border: #30363d;
--font-mono: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
/* Tag Colors */
        --tag-sys: #a371f7;
        --tag-tgt: #d29922;
        --tag-dmy: #3fb950;
        --tag-allie: #00d9ff;
        --tag-enemy: #ff4500;
        --tag-plr: #3fb950;
    }

    * { box-sizing: border-box; }

    body {
        margin: 0;
        padding: 0;
        background-color: var(--bg-color);
        color: var(--text-main);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    /* Layout */
    header {
        height: 40px;
        background: var(--panel-bg);
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        padding: 0 1rem;
        justify-content: space-between;
    }

    h1 { font-size: 14px; margin: 0; font-weight: 600; color: var(--accent); letter-spacing: 0.5px; }

    #workspace {
        flex: 1;
        display: flex;
        overflow: hidden;
    }

    /* Canvas Area */
    #viewport {
        flex: 1;
        position: relative;
        background-color: var(--bg-color); 
        cursor: crosshair;
        overflow: hidden;
    }

    canvas { display: block; width: 100%; height: 100%; }

    #overlay-ui {
        position: absolute;
        top: 10px;
        left: 10px;
        pointer-events: none;
        font-family: var(--font-mono);
        font-size: 11px;
        color: var(--success);
        text-shadow: 0 1px 2px black;
    }

    /* Range Legend */
    #range-legend {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background: rgba(22, 27, 34, 0.95);
        border: 1px solid var(--border);
        border-radius: 4px;
        padding: 8px 12px;
        pointer-events: none;
        font-family: var(--font-mono);
        font-size: 10px;
        color: var(--text-main);
        display: none;
    }

    #range-legend.visible {
        display: block;
    }

    .legend-title {
        font-weight: bold;
        color: var(--accent);
        margin-bottom: 4px;
        font-size: 11px;
    }

    .legend-item {
        display: flex;
        align-items: center;
        margin: 2px 0;
        gap: 8px;
    }

    .legend-color {
        width: 20px;
        height: 2px;
        border-radius: 1px;
    }

    /* Controls Sidebar */
    #controls {
        width: 460px;
        background: var(--panel-bg);
        border-left: 1px solid var(--border);
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        font-size: 12px;
    }

    .panel-section {
        padding: 10px;
        border-bottom: 1px solid var(--border);
    }

    .panel-title {
        font-weight: bold;
        color: var(--text-dim);
        text-transform: uppercase;
        font-size: 10px;
        margin-bottom: 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    /* Widgets */
    .control-group {
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    label { color: var(--text-main); flex: 1; margin-right: 10px; white-space: nowrap; display: flex; align-items: center;}
    
    input[type="range"] {
        flex: 2;
        height: 4px;
        background: var(--border);
        border-radius: 2px;
        appearance: none;
    }
    input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        width: 12px;
        height: 12px;
        background: var(--accent);
        border-radius: 50%;
        cursor: pointer;
    }

    input[type="number"] {
        width: 70px;
        padding: 4px;
        background: var(--bg-color);
        color: var(--text-main);
        border: 1px solid var(--border);
        border-radius: 3px;
        font-size: 11px;
        font-family: var(--font-mono);
    }

    input[type="checkbox"] {
        cursor: pointer;
    }

    input[type="text"] { /* SMALL FIX #3: text input styling for profile creator */
        width: 100%;
        padding: 4px;
        background: var(--bg-color);
        color: var(--text-main);
        border: 1px solid var(--border);
        border-radius: 3px;
        font-size: 11px;
        font-family: var(--font-mono);
    }

    .val-display { width: 50px; text-align: right; color: var(--accent); font-family: var(--font-mono); font-size: 11px; }

    select {
        background: var(--border);
        color: var(--text-main);
        border: 1px solid rgba(255,255,255,0.1);
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 11px;
        flex: 1;
    }

    button {
        background: var(--border);
        color: var(--text-main);
        border: 1px solid rgba(255,255,255,0.1);
        padding: 4px 8px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 11px;
        transition: background 0.2s;
    }
    button:hover { background: #3c444d; }
    button.primary { background: var(--success); color: white; border: none; }
    button.danger { background: var(--danger); color: white; border: none; }
    
    /* Active Mode Button Style */
    button.mode-active {
        background: var(--accent);
        color: #0d1117;
        border-color: var(--accent);
        font-weight: bold;
    }

    /* Ownership Tags */
    .tag {
        font-size: 9px;
        padding: 1px 3px;
        border-radius: 3px;
        margin-right: 6px;
        font-family: var(--font-mono);
        font-weight: bold;
        color: #0d1117;
    }
    .tag-sys { background-color: var(--tag-sys); }
    .tag-tgt { background-color: var(--tag-tgt); }
    .tag-dmy { background-color: var(--tag-dmy); }
    .tag-allie { background-color: var(--tag-allie); } /* SMALL FIX #5 */
    .tag-enemy { background-color: var(--tag-enemy); } /* SMALL FIX #5 */
    .tag-plr { background-color: var(--tag-plr); }

    .legend-row {
        display: flex; gap: 10px; font-size: 10px; color: var(--text-dim); margin-top: 5px;
    }

    /* Logs */
    #log-panel {
        flex: 1;
        background: #000;
        font-family: var(--font-mono);
        padding: 5px;
        overflow-y: auto;
        font-size: 10px;
        border-top: 1px solid var(--border);
        max-height: 200px;
        min-height: 100px;
    }
    .log-entry { margin-bottom: 2px; border-bottom: 1px solid #111; padding-bottom: 2px; }
    .log-time { color: var(--text-dim); margin-right: 5px; }
    .log-type-INFO { color: var(--accent); }
    .log-type-LOCK { color: var(--warning); }
    .log-type-WARN { color: var(--danger); }
    .log-tag { font-weight: bold; margin-right: 4px; }

    /* Modal/Assumptions */
    .modal {
        display: none;
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8);
        z-index: 100;
        justify-content: center;
        align-items: center;
    }
    .modal-content {
        background: var(--panel-bg);
        border: 1px solid var(--border);
        width: 700px;
        max-height: 80vh;
        overflow-y: auto;
        padding: 20px;
        border-radius: 6px;
    }
    .modal-header { font-size: 16px; margin-bottom: 15px; border-bottom: 1px solid var(--border); padding-bottom: 10px;}
    .assumption-list li { margin-bottom: 5px; color: var(--text-dim); }
    
    /* Utility classes */
    .flex-row { display: flex; gap: 5px; }
    .active-entity { border-left: 3px solid var(--accent); background: rgba(88, 166, 255, 0.1); }
    
    /* Entity List */
    #entity-list { max-height: 150px; overflow-y: auto; }
    .entity-item { 
        padding: 4px; border-bottom: 1px solid var(--border); 
        cursor: pointer; display: flex; justify-content: space-between; align-items: center;
    }
    .entity-item:hover { background: rgba(255,255,255,0.05); }

    /* Ship Profile Info */
    .profile-info {
        font-size: 10px;
        color: var(--text-dim);
        margin-top: 3px;
        font-style: italic;
    }

    /* SMALL FIX #6: Fixed incoming lock indicator layout with flex and gaps */
    /* ---------- Incoming lock: improved placement, colors & responsive ---------- */
.threat-indicator {
    /* Move to top-right inside the viewport so it won't overlap the top-left HUD */
    position: absolute;
    top: 12px;
    right: 12px;
    z-index: 200; /* sit above most UI, but below global modals if any */

    /* Visuals */
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 14px;
    border-radius: 8px;
    min-width: 160px;
    max-width: 360px;
    box-sizing: border-box;
    pointer-events: none; /* non-interactive overlay */

    /* Better contrast + subtle glass effect */
    background: linear-gradient(180deg, rgba(20,16,16,0.70), rgba(20,16,16,0.55));
    border: 1px solid rgba(248,81,73,0.35);
    backdrop-filter: blur(6px) saturate(120%);

    /* Text */
    color: var(--danger);
    font-family: var(--font-mono);
    font-size: 12px;
    font-weight: 700;
    text-shadow: 0 1px 0 rgba(0,0,0,0.6);

    /* Prevent internal text overflow, but allow wrap when needed */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;

    /* Depth */
    box-shadow: 0 8px 20px rgba(0,0,0,0.6);
}

/* small icon (optional inside markup) */
    .threat-indicator .ti-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: linear-gradient(180deg, rgba(248,81,73,1), rgba(255,120,100,1));
        color: #0d1117;
        font-size: 13px;
        flex: 0 0 20px;
        box-shadow: 0 2px 6px rgba(248,81,73,0.25);
    }

/* make the message body readable if it wraps */
    .threat-indicator .ti-text {
        overflow: visible;
        white-space: normal;
        font-weight: 700;
        line-height: 1.1;
    }

/* If you hide it via inline style/display, prefer aria-hidden attribute toggle:
   .threat-indicator[aria-hidden="true"] { display: none; } */

/* Responsive: on narrow viewports move to bottom-center and allow multi-line (no overlap with bottom-right legend) */
    /* MOBILE: keep threat indicator at the TOP (centered) so it never overlaps bottom-right HUD/legend */
    @media (max-width: 760px) {
        .threat-indicator {
            /* force top-centered placement (instead of bottom-center) */
            top: 12px;
            bottom: auto;
            left: 50%;
            right: auto;
            transform: translateX(-50%);
            max-width: 92%;
            white-space: normal;
            text-overflow: clip;
            padding: 10px 12px;
        }
    }
    /* Control por clase: mostrar/ocultar con clase (por si se usa toggle) */
    .threat-indicator { display: none; }               /* default hiddeable */
    .threat-indicator.visible { display: flex !important; }

    /* Si el threat está visible, subimos la leyenda de rango para evitar solapamiento */
    #range-legend {
        transition: bottom 0.12s ease;
    }
    #range-legend.shift-up {
        bottom: 70px; /* eleva la leyenda para dejar espacio al indicador */
    }

    /* Asegurarnos que el legend esté encima si hace falta (pero preferimos moverlo) */
    #range-legend { z-index: 150; }
    .threat-indicator { z-index: 200; }
    /* Dual input groups (slider + number) */
    .dual-input-group {
        display: flex;
        gap: 8px;
        align-items: center;
        flex: 2;
    }

    .dual-input-group input[type="range"] {
        flex: 1;
    }

    /* SMALL FIX #3: Profile creator form styling */
    .profile-creator {
        background: rgba(88, 166, 255, 0.05);
        border: 1px solid var(--border);
        padding: 8px;
        border-radius: 4px;
        margin-top: 8px;
    }

    .profile-creator h4 {
        margin: 0 0 8px 0;
        font-size: 11px;
        color: var(--accent);
    }

    .profile-creator .control-group {
        margin-bottom: 6px;
    }

    .profile-creator label {
        font-size: 10px;
    }

    .profile-creator input[type="number"],
    .profile-creator input[type="text"],
    .profile-creator select {
        width: 100%;
    }

</style>
</head>
<body>

<header>
<div style="display:flex; align-items:center; gap:15px;">
<h1>Sensor and Lock Mechanics Sandbox v4.2</h1>
<div class="flex-row">
<button id="btn-play">Pause</button>
<button id="btn-step">Step</button>
<button id="btn-reset">Reset</button>
</div>
</div>
<div class="flex-row">
<button id="btn-debug">Debug Overlays</button>
<button id="btn-test-preset">Import State</button>
<button id="btn-assumptions">System Info</button>
<button id="btn-export">Export State</button>
<button id="btn-run-tests">Run Perf Tests</button>
</div>
</header>

<div id="workspace">
<div id="viewport">
<canvas id="main-canvas"></canvas>
<div id="overlay-ui">
<div>PLAYER POS: <span id="hud-player-pos">0,0</span></div>
<div>PLAYER: <span id="hud-player-state">ACTIVE</span></div>
<div>CONTACTS: <span id="hud-contacts">0</span></div>
<div>LOCK OUT: <span id="hud-lock-outgoing">NONE (0%)</span></div>
<div>LOCK IN: <span id="hud-lock-incoming">NONE</span></div>
<div style="margin-top: 5px; color: var(--text-dim);" id="hud-selection"></div>
</div>
<div id="range-legend" class="visible">
    <div class="legend-title">RANGE RINGS</div>
    <div class="legend-item">
        <div class="legend-color" style="background: rgba(88, 166, 255, 0.3);"></div>
        <span>Entity Relative</span>
    </div>
    <div class="legend-item">
        <div class="legend-color" style="background: rgba(63, 185, 80, 0.3);"></div>
        <span>Player Detection Range</span>
    </div>
    <div class="legend-item">
        <div class="legend-color" style="background: rgba(210, 153, 34, 0.3);"></div>
        <span>Weapon Effective Range</span>
    </div>
</div>
<div id="threat-warning" class="threat-indicator" style="display:none;">
⚠ INCOMING LOCK DETECTED
</div>
</div>
<div id="controls">
    <div class="panel-section">
        <div class="panel-title">CONTROL LEGEND</div>
        <div class="legend-row">
            <div><span class="tag tag-sys">SYS</span>System</div>
            <div><span class="tag tag-plr">PLR</span>Player</div>
            <div><span class="tag tag-tgt">TGT</span>Target</div>
            <div><span class="tag tag-allie">ALLIE</span>Allie</div> <!-- SMALL FIX #5 -->
            <div><span class="tag tag-enemy">ENEMY</span>Enemy</div> <!-- SMALL FIX #5 -->
        </div>
    </div>

    <div class="panel-section">
        <div class="panel-title">PLAYER CONTROLS</div>
        <div class="control-group">
            <label><span class="tag tag-plr">PLR</span>Ship Type</label>
            <select id="player-ship-type">
                </select>
        </div>
        <div class="profile-info" id="player-profile-description"></div>
        
        <div class="control-group">
            <label><span class="tag tag-plr">PLR</span>Velocity (m/s)</label>
            <div class="dual-input-group">
                <input type="range" id="player-vel" min="0" max="200" step="1" value="0">
                <input type="number" id="player-vel-num" min="0" max="200" step="1" value="0">
            </div>
        </div>
        <div class="control-group">
            <label><span class="tag tag-plr">PLR</span>Heading (deg)</label>
            <div class="dual-input-group">
                <input type="range" id="player-head" min="0" max="360" step="5" value="0">
                <input type="number" id="player-head-num" min="0" max="360" step="1" value="0">
            </div>
        </div>
        <div class="control-group">
            <label><span class="tag tag-plr">PLR</span>Weapons Firing</label>
            <input type="checkbox" id="player-weapons">
        </div>
        <div class="control-group">
            <label><span class="tag tag-plr">PLR</span>Sensor Mode</label>
            <div class="flex-row" id="sensor-mode-group">
                <button id="btn-sensor-active">Active</button>
                <button id="btn-sensor-passive">Passive</button>
            </div>
        </div>
        <div class="control-group">
            <label><span class="tag tag-plr">PLR</span>Sensor Power</label>
            <div class="dual-input-group">
                <input type="range" id="player-sensor-power" min="0.1" max="2.0" step="0.1" value="1.0">
                <input type="number" id="player-sensor-power-num" min="0.1" max="2.0" step="0.1" value="1.0">
            </div>
        </div>

        <!-- SMALL FIX #3: Custom Ship Profile Creator -->
        <div class="profile-creator">
            <h4>CREATE CUSTOM SHIP PROFILE</h4>
            <div class="control-group">
                <label>Profile Name</label>
                <input type="text" id="custom-profile-name" placeholder="e.g., Custom Fighter">
            </div>
            <div class="control-group">
                <label>Base Signature</label>
                <input type="number" id="custom-profile-sig" min="1" max="200" step="1" value="20">
            </div>
            <div class="control-group">
                <label>Activity Gain</label>
                <input type="number" id="custom-profile-gain" min="0.1" max="5.0" step="0.1" value="1.5">
            </div>
            <div class="control-group">
                <label>Size Class</label>
                <select id="custom-profile-size">
                    <option value="frigate">Frigate</option>
                    <option value="cruiser">Cruiser</option>
                    <option value="capital">Capital</option>
                </select>
            </div>
            <div class="control-group">
                <label>Description</label>
                <input type="text" id="custom-profile-desc" placeholder="Short description">
            </div>
            <button id="btn-save-profile" class="primary" style="width:100%; margin-top:5px;">Save Profile</button>
        </div>
    </div>

    <div class="panel-section">
        <div class="panel-title">SPAWN DEFAULTS</div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Default Ship Type</label>
            <select id="default-ship-profile">
                </select>
        </div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Default Team</label>
            <select id="default-team">
                <option value="player">Allie Team</option> <!-- SMALL FIX #5 -->
                <option value="enemy">Enemy Team</option>
            </select>
        </div>
        <div class="profile-info" id="profile-description">
            Select a ship profile to see description
        </div>
    </div>

    <div class="panel-section">
        <div class="panel-title">DETECTION SYSTEM</div>
        <div id="params-detection-container"></div>
    </div>

    <div class="panel-section">
        <div class="panel-title">TRACKING & LOCK</div>
        <div id="params-tracking-container"></div>
    </div>

    <div class="panel-section">
        <div class="panel-title">WEAPON HIT PROBABILITY</div>
        <div id="params-weapon-container"></div>
    </div>

    <div class="panel-section">
        <div class="panel-title">ADVANCED SYSTEM MATH</div>
        <div id="params-math-container"></div>
    </div>

    <div class="panel-section">
        <div class="panel-title">PERFORMANCE & DEBUG</div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Debug Mode</label>
            <select id="debug-mode-select">
                <option value="off">Off</option>
                <option value="perf">Performance (Minimal Info)</option>
                <option value="heavy">Heavy (Full Telemetry)</option>
            </select>
        </div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Show Range Rings</label>
            <input type="checkbox" id="show-range-rings" checked>
        </div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Show Range Legend</label>
            <input type="checkbox" id="show-range-legend" checked>
        </div>
    </div>

    <div class="panel-section">
        <div class="panel-title">VIEW CONTROLS</div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Zoom Level</label>
            <input type="range" id="zoom-slider" min="0.05" max="5" step="0.05" value="0.15">
            <span class="val-display" id="zoom-val">0.15</span> <!-- SMALL FIX #4: default zoom 2x further -->
        </div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Debug Overlays</label>
            <input type="checkbox" id="debug-toggle">
        </div>
    </div>

    <div class="panel-section">
        <div class="panel-title">
            ENTITIES
            <button id="btn-spawn" class="primary">Spawn</button>
        </div>
        <div id="entity-list"></div>
    </div>

    <div class="panel-section" id="selection-panel" style="display:none;">
        <div class="panel-title">TARGET <span id="sel-id">---</span></div>
        
        <div class="control-group">
            <label><span class="tag tag-tgt">TGT</span>Ship Type</label>
            <select id="sel-ship-type">
                </select>
        </div>

        <div class="control-group">
            <label><span class="tag tag-tgt">TGT</span>Team</label>
            <select id="sel-team">
                <option value="player">Allie Team</option> <!-- SMALL FIX #5 -->
                <option value="enemy">Enemy Team</option>
            </select>
        </div>

        <!-- SMALL FIX #2: Removed sliders, kept number-only inputs with step=1 -->
        <div class="control-group">
            <label><span class="tag tag-tgt">TGT</span>Velocity (m/s)</label>
            <input type="number" id="sel-vel-num" min="0" max="200" step="1" value="50">
        </div>
        <div class="control-group">
            <label><span class="tag tag-tgt">TGT</span>Heading (deg)</label>
            <input type="number" id="sel-head-num" min="0" max="360" step="1" value="0">
        </div>
        <div class="control-group">
            <label><span class="tag tag-tgt">TGT</span>Weapons Firing</label>
            <input type="checkbox" id="sel-weapons">
        </div>
        <div class="control-group">
            <label><span class="tag tag-tgt">TGT</span>Sensor Mode</label>
            <select id="sel-sensor-mode">
                <option value="Active">Active</option>
                <option value="Passive">Passive</option>
            </select>
        </div>
        <div class="control-group">
            <label><span class="tag tag-tgt">TGT</span>Sensor Power</label>
            <input type="number" id="sel-sensor-power-num" min="0.1" max="2.0" step="0.1" value="1.0">
        </div>
        <div class="control-group">
            <label><span class="tag tag-tgt">TGT</span>ECM Level</label>
            <input type="number" id="sel-ecm-num" min="0" max="5" step="0.1" value="0">
        </div>
        
        <div style="margin-top:10px; padding-top:10px; border-top:1px solid var(--border); font-size:10px; color:var(--text-dim);">
            <div>Signature: <span id="info-sig" style="color:var(--accent)">0</span></div>
            <div>Activity: <span id="info-activity" style="color:var(--accent)">0%</span></div>
            <div>Detection: <span id="info-detection" style="color:var(--accent)">0</span></div>
        </div>
    </div>

    <div id="log-panel"></div>
</div>
</div>

<!-- Modal for Assumptions -->
<div id="assumptions-modal" class="modal">
<div class="modal-content">
<div class="modal-header">SYSTEM ASSUMPTIONS & MECHANICS</div>
<ul class="assumption-list">
    <li><strong>Performance Optimizations:</strong> Heavy math operations (tanh, exp, atan) replaced with cheaper approximations</li>
    <li><strong>Activity Level:</strong> Uses softstep (smoothstep) approximation instead of tanh</li>
    <li><strong>Signature Computation:</strong> Uses log1p-based approximation for activity boost</li>
    <li><strong>Detection Score:</strong> Uses inverse-square falloff with cheaper log1p signature scaling</li>
    <li><strong>Angular Tracking:</strong> Uses polynomial approximation instead of atan for tracking difficulty</li>
    <li><strong>Clustering:</strong> Spatial hash grid for O(n) average complexity instead of O(n²)</li>
    <li><strong>Distance Caching:</strong> Quantized distance computations reduce redundant calculations</li>
    <li><strong>Debug Modes:</strong> 'Performance' shows minimal info, 'Heavy' shows full granular telemetry</li>
    <li><strong>Relative Range Rings:</strong> Each entity shows detection/weapon range rings relative to its position</li>
    <li><strong>Deterministic:</strong> All outputs are deterministic, no random toggling of debug state</li>
</ul>
<button onclick="document.getElementById('assumptions-modal').style.display='none'">Close</button>
</div>
</div>

<!-- SMALL FIX #9: Import State Modal -->
<div id="import-modal" class="modal">
<div class="modal-content">
<div class="modal-header">IMPORT STATE FROM JSON</div>
<div style="margin-bottom: 10px;">
    <label for="import-file-input">Select JSON file:</label>
    <input type="file" id="import-file-input" accept=".json" style="width: 100%; margin-top: 5px;">
</div>
<div style="display: flex; gap: 10px;">
    <button id="btn-import-confirm" class="primary">Import</button>
    <button onclick="document.getElementById('import-modal').style.display='none'">Cancel</button>
</div>
</div>
</div>

<script>

// =========================================================================
// PERFORMANCE COUNTERS (for test harness validation)
// =========================================================================

const PERF_COUNTERS = {
    activityComputations: 0,
    signatureComputations: 0,
    detectionScoreComputations: 0,
    lockStateComputations: 0,
    clusterOperations: 0,
    distanceComputations: 0,
    angularVelocityComputations: 0,
    
    // Expensive ops tracking
    tanhCalls: 0,
    expCalls: 0,
    atanCalls: 0,
    sqrtCalls: 0,
    
    reset: function() {
        this.activityComputations = 0;
        this.signatureComputations = 0;
        this.detectionScoreComputations = 0;
        this.lockStateComputations = 0;
        this.clusterOperations = 0;
        this.distanceComputations = 0;
        this.angularVelocityComputations = 0;
        this.tanhCalls = 0;
        this.expCalls = 0;
        this.atanCalls = 0;
        this.sqrtCalls = 0;
    },
    
    getReport: function() {
        return {
            total_function_calls: this.activityComputations + this.signatureComputations + 
                                 this.detectionScoreComputations + this.lockStateComputations + 
                                 this.clusterOperations + this.distanceComputations + 
                                 this.angularVelocityComputations,
            expensive_ops: this.tanhCalls + this.expCalls + this.atanCalls,
            breakdown: {
                activity: this.activityComputations,
                signature: this.signatureComputations,
                detection: this.detectionScoreComputations,
                lockState: this.lockStateComputations,
                clustering: this.clusterOperations,
                distance: this.distanceComputations,
                angularVel: this.angularVelocityComputations
            },
            expensive_breakdown: {
                tanh: this.tanhCalls,
                exp: this.expCalls,
                atan: this.atanCalls,
                sqrt: this.sqrtCalls
            }
        };
    }
};

// =========================================================================
// FAST MATH APPROXIMATIONS
// =========================================================================

const FastMath = {
    // Softstep (smoothstep) approximation for activity - replaces tanh
    // Monotonic, smooth, and much faster than tanh
    softstep: function(x) {
        if (x <= 0) return 0;
        if (x >= 1) return 1;
        return x * x * (3 - 2 * x);
    },
    
    // log1p-based signature approximation
    log1pNormalized: function(x, k) {
        const xk = x * k;
        return xk / (1 + xk);
    },
    
    // Inverse square approximation for detection falloff
    inverseSquareFalloff: function(distanceKm, effectiveRange) {
        const ratio = distanceKm / effectiveRange;
        return 1 / (1 + ratio * ratio);
    },
    
    // Fast polynomial approximation for atan (minimax for [-1, 1])
    fastAtanAccurate: function(x) {
        if (x < -1) {
            return -Math.PI/2 - this.fastAtanAccurate(1/x);
        }
        if (x > 1) {
            return Math.PI/2 - this.fastAtanAccurate(1/x);
        }
        const x2 = x * x;
        return x * (0.99997726 + x2 * (-0.33262347 + x2 * (0.19354346 + x2 * (-0.11643287 + x2 * 0.05265332))));
    },
    
    // Fast sigmoid (logistic function) approximation
    fastSigmoid: function(x) {
        if (x < -4) return 0;
        if (x > 4) return 1;
        const normalized = (x + 4) / 8;
        return this.softstep(normalized);
    }
};

// =========================================================================
// SPATIAL HASH GRID (for fast clustering)
// =========================================================================

class SpatialHashGrid {
    constructor(cellSize) {
        this.cellSize = cellSize || 5000; // meters (5km default)
        this.grid = new Map();
    }
    
    clear() {
        this.grid.clear();
    }
    
    _hashKey(x, y) {
        const cx = Math.floor(x / this.cellSize);
        const cy = Math.floor(y / this.cellSize);
        return `${cx},${cy}`;
    }
    
    insert(entity, x, y) {
        const key = this._hashKey(x, y);
        if (!this.grid.has(key)) {
            this.grid.set(key, []);
        }
        this.grid.get(key).push(entity);
    }
    
    queryRadius(x, y, radius) {
        const results = [];
        const cellRadius = Math.ceil(radius / this.cellSize);
        const cx = Math.floor(x / this.cellSize);
        const cy = Math.floor(y / this.cellSize);
        
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                const key = `${cx + dx},${cy + dy}`;
                const cell = this.grid.get(key);
                if (cell) {
                    results.push(...cell);
                }
            }
        }
        return results;
    }
}

// =========================================================================
// DISTANCE CACHE (quantized to reduce redundant calculations)
// =========================================================================

const DistanceCache = {
    _cache: new Map(),
    _quantizeStep: 10, // meters
    
    _quantizePos(x, y) {
        const qx = Math.floor(x / this._quantizeStep) * this._quantizeStep;
        const qy = Math.floor(y / this._quantizeStep) * this._quantizeStep;
        return `${qx},${qy}`;
    },
    
    get(x1, y1, x2, y2) {
        const key = `${this._quantizePos(x1, y1)}_${this._quantizePos(x2, y2)}`;
        return this._cache.get(key);
    },
    
    set(x1, y1, x2, y2, distance) {
        const key = `${this._quantizePos(x1, y1)}_${this._quantizePos(x2, y2)}`;
        this._cache.set(key, distance);
        
        if (this._cache.size > 1000) {
            const firstKey = this._cache.keys().next().value;
            this._cache.delete(firstKey);
        }
    },
    
    clear() {
        this._cache.clear();
    }
};

// =========================================================================
// IMPROVED SENSOR MATH (with performance optimizations)
// =========================================================================

const ImprovedSensorMath = {
    clamp: function(val, min, max) {
        return Math.max(min, Math.min(max, val));
    }
};

ImprovedSensorMath.SHIP_PROFILES = {
    "Interceptor": {
        baseSignature: 15,      // dimensionless score
        activityGain: 1.8,      // dimensionless multiplier
        size: "frigate",
        description: "Fast, low signature craft"
    },
    "Corvette": {
        baseSignature: 18,      // dimensionless score
        activityGain: 1.6,      // dimensionless multiplier
        size: "frigate",
        description: "Small patrol vessel"
    },
    "Light Frigate": {
        baseSignature: 25,      // dimensionless score
        activityGain: 1.7,      // dimensionless multiplier
        size: "frigate",
        description: "Basic combat vessel"
    },
    "Heavy Frigate": {
        baseSignature: 35,      // dimensionless score
        activityGain: 2.0,      // dimensionless multiplier
        size: "frigate",
        description: "Reinforced multi-role frigate"
    },
    "Destroyer": {
        baseSignature: 45,      // dimensionless score
        activityGain: 2.1,      // dimensionless multiplier
        size: "cruiser",
        description: "Line combat vessel"
    },
    "Light Cruiser": {
        baseSignature: 55,      // dimensionless score
        activityGain: 2.2,      // dimensionless multiplier
        size: "cruiser",
        description: "Multi-role capital ship"
    },
    "Battlecruiser": {
        baseSignature: 65,      // dimensionless score
        activityGain: 2.3,      // dimensionless multiplier
        size: "cruiser",
        description: "Heavy firepower platform"
    },
    "Carrier": {
        baseSignature: 90,      // dimensionless score
        activityGain: 2.5,      // dimensionless multiplier
        size: "capital",
        description: "Fighter operations, always visible"
    },
    "Dreadnought": {
        baseSignature: 85,      // dimensionless score
        activityGain: 2.4,      // dimensionless multiplier
        size: "capital",
        description: "Maximum firepower, impossible to hide"
    },
    "Command Ship": {
        baseSignature: 75,      // dimensionless score
        activityGain: 2.6,      // dimensionless multiplier
        size: "capital",
        description: "C&C vessel with high sensor emissions"
    }
};

// SMALL FIX #3: Load custom profiles from localStorage
ImprovedSensorMath.loadCustomProfiles = function() {
    try {
        const stored = localStorage.getItem('customShipProfiles');
        if (stored) {
            const custom = JSON.parse(stored);
            Object.assign(ImprovedSensorMath.SHIP_PROFILES, custom);
        }
    } catch (e) {
        console.error('Failed to load custom profiles:', e);
    }
};

// SMALL FIX #3: Save custom profile to localStorage
ImprovedSensorMath.saveCustomProfile = function(name, profile) {
    try {
        const stored = localStorage.getItem('customShipProfiles');
        const custom = stored ? JSON.parse(stored) : {};
        custom[name] = profile;
        localStorage.setItem('customShipProfiles', JSON.stringify(custom));
        ImprovedSensorMath.SHIP_PROFILES[name] = profile;
        return true;
    } catch (e) {
        console.error('Failed to save custom profile:', e);
        return false;
    }
};

ImprovedSensorMath.getShipProfile = function(shipName){
    if(!shipName) shipName = '';
    const normalize = s => String(s).replace(/[\s\-_]/g,'').toLowerCase();
    if(!ImprovedSensorMath._profileLookup){
        ImprovedSensorMath._profileLookup = {};
        Object.keys(ImprovedSensorMath.SHIP_PROFILES).forEach(k=>{
            ImprovedSensorMath._profileLookup[ normalize(k) ] = ImprovedSensorMath.SHIP_PROFILES[k];
        });
    }
    const found = ImprovedSensorMath._profileLookup[ normalize(shipName) ];
    if(found) return found;
    if(ImprovedSensorMath.SHIP_PROFILES[shipName]) return ImprovedSensorMath.SHIP_PROFILES[shipName];
    return { baseSignature: 20, activityGain: 1.5, size: "frigate", description: "Default profile" };
};

ImprovedSensorMath.getAvailableShipTypes = function() {
    return Object.keys(ImprovedSensorMath.SHIP_PROFILES);
};

ImprovedSensorMath.computeActivityLevel = function(velocityRatio, weaponsFiring, radarActive) {
    PERF_COUNTERS.activityComputations++;
    
    velocityRatio = Math.max(0, Math.min(1, Number(velocityRatio) || 0));
    const velWeight = CONFIG.get('MATH_VEL_WEIGHT');
    const weaponWeight = CONFIG.get('MATH_WEAPON_WEIGHT');
    const radarWeight = CONFIG.get('MATH_RADAR_WEIGHT');
    const sensitivity = CONFIG.get('MATH_SENSITIVITY');
    
    let rawActivity = velocityRatio * velWeight;
    if (weaponsFiring) rawActivity += weaponWeight;
    if (radarActive) rawActivity += radarWeight;
    
    const centered = sensitivity * (rawActivity - 1.0);
    const normalized = (centered + 3) / 6;
    return FastMath.softstep(Math.max(0, Math.min(1, normalized)));
};

ImprovedSensorMath.computeSignature = function(shipType, activityLevel) {
    PERF_COUNTERS.signatureComputations++;
    
    const profile = ImprovedSensorMath.getShipProfile(shipType);
    const baseSig = Math.max(0, Number(profile.baseSignature) || 0);
    const gain = Math.max(0, Number(profile.activityGain) || 0);
    activityLevel = ImprovedSensorMath.clamp(Number(activityLevel) || 0, 0.0, 1.0);
    const k = CONFIG.get('MATH_SIG_K');
    
    const activityBoostNormalized = FastMath.log1pNormalized(activityLevel, k);
    const activityBoost = activityBoostNormalized * gain;
    return Math.max(0, baseSig * (1 + activityBoost));
};

ImprovedSensorMath.computeDetectionScore = function(signature, sensorPower, distanceM, opts = {}) {
    PERF_COUNTERS.detectionScoreComputations++;
    
    signature = Math.max(0, Number(signature) || 0);
    sensorPower = Math.max(0, Number(sensorPower) || 0);
    distanceM = Number(distanceM);
    if (!isFinite(distanceM) || distanceM <= 0) distanceM = 1;
    if (signature <= 0 || sensorPower <= 0) return 0;
    
    const distanceKm = distanceM / 1000;
    const effectiveRange = ('effectiveRange' in opts) ? Number(opts.effectiveRange) : CONFIG.get('MATH_EFFECTIVE_RANGE');
    const peakScore = ('peakScore' in opts) ? Number(opts.peakScore) : CONFIG.get('MATH_PEAK_SCORE');
    const referenceStrength = ('referenceStrength' in opts) ? Number(opts.referenceStrength) : CONFIG.get('MATH_REF_STRENGTH');
    
    const strength = (signature * sensorPower) / referenceStrength;
    const strengthFactor = FastMath.log1pNormalized(strength, 1.0);
    const distanceFactor = FastMath.inverseSquareFalloff(distanceKm, effectiveRange);
    
    return peakScore * strengthFactor * distanceFactor;
};

ImprovedSensorMath.isDetected = function(detectionScore, detectionThreshold) {
    detectionScore = Number(detectionScore) || 0;
    detectionThreshold = (typeof detectionThreshold === 'number') ? detectionThreshold : 15;
    detectionThreshold = Math.max(0, Number(detectionThreshold) || 0);
    return detectionScore >= detectionThreshold;
};

ImprovedSensorMath.computeDetectionRange = function(signature, sensorPower, threshold, opts = {}) {
    signature = Math.max(0, Number(signature) || 0);
    sensorPower = Math.max(0, Number(sensorPower) || 0);
    threshold = Math.max(0, Number(threshold) || 0);
    if (threshold <= 0) return Infinity;
    if (signature <= 0 || sensorPower <= 0) return 0;
    
    const peakScore = ('peakScore' in opts) ? Number(opts.peakScore) : CONFIG.get('MATH_PEAK_SCORE');
    const effectiveRange = ('effectiveRange' in opts) ? Number(opts.effectiveRange) : CONFIG.get('MATH_EFFECTIVE_RANGE');
    const referenceStrength = ('referenceStrength' in opts) ? Number(opts.referenceStrength) : CONFIG.get('MATH_REF_STRENGTH');
    
    const strength = (signature * sensorPower) / referenceStrength;
    const strengthFactor = FastMath.log1pNormalized(strength, 1.0);
    
    const maxScore = peakScore * strengthFactor;
    if (maxScore < threshold) return 0;
    
    const ratio = threshold / maxScore;
    if (ratio >= 1) return 0;
    
    const sqrtArg = (maxScore / threshold) - 1;
    if (sqrtArg < 0) return 0;
    
    PERF_COUNTERS.sqrtCalls++;
    const rangeKm = effectiveRange * Math.sqrt(sqrtArg);
    return Math.max(0, rangeKm * 1000);
};

ImprovedSensorMath.computeAngularVelocity = function(target_pos, target_vel, observer_pos, observer_vel) {
    PERF_COUNTERS.angularVelocityComputations++;
    
    const tx = (target_pos.x || 0) - (observer_pos.x || 0);
    const ty = (target_pos.y || 0) - (observer_pos.y || 0);
    const tz = ((target_pos.z || 0) - (observer_pos.z || 0));

    PERF_COUNTERS.sqrtCalls++;
    const dist = Math.sqrt(tx*tx + ty*ty + tz*tz);
    const minDist = 0.0001;

    if (!isFinite(dist) || dist < minDist) return [0.0, 0.0];

    const dir_x = tx / dist;
    const dir_y = ty / dist;
    const dir_z = tz / dist;

    const rvx = (target_vel.x || 0) - (observer_vel.x || 0);
    const rvy = (target_vel.y || 0) - (observer_vel.y || 0);
    const rvz = ((target_vel.z || 0) - (observer_vel.z || 0));

    const dot = rvx * dir_x + rvy * dir_y + rvz * dir_z;
    const lin_x = dot * dir_x;
    const lin_y = dot * dir_y;
    const lin_z = dot * dir_z;

    const trans_x = rvx - lin_x;
    const trans_y = rvy - lin_y;
    const trans_z = rvz - lin_z;

    PERF_COUNTERS.sqrtCalls++;
    const transversal_speed = Math.sqrt(trans_x*trans_x + trans_y*trans_y + trans_z*trans_z);
    const angular_velocity = transversal_speed / dist;

    if (!isFinite(angular_velocity) || !isFinite(transversal_speed)) return [0.0, 0.0];

    return [angular_velocity, transversal_speed];
};

ImprovedSensorMath.computeLockState = function(detectionScore, angularVelocity, trackingTime, trackingSpeed) {
    PERF_COUNTERS.lockStateComputations++;
    
    trackingSpeed = Math.max(0.01, trackingSpeed || 0.1);
    const minDetection = CONFIG.get('MATH_MIN_DETECTION');
    const fullLockDetection = CONFIG.get('MATH_FULL_LOCK_DETECT');
    const optimalTrackTime = CONFIG.get('MATH_OPTIMAL_TRACK_TIME');
    const maxAngularPenalty = CONFIG.get('MATH_MAX_ANG_PENALTY');

    const detectionFactor = FastMath.fastSigmoid(0.1 * (detectionScore - fullLockDetection));
    
    const angularRatio = angularVelocity / trackingSpeed;
    const atanResult = FastMath.fastAtanAccurate(angularRatio);
    const trackingDifficulty = atanResult / (Math.PI / 2);
    
    const trackingFactor = 1 - (trackingDifficulty * maxAngularPenalty);
    const timeFactor = FastMath.fastSigmoid(3 * (trackingTime / optimalTrackTime - 0.5));
    
    const lockQuality = detectionFactor * trackingFactor * timeFactor;

    let state = "ACQUIRING";
    if (lockQuality > 0.75 && detectionScore > fullLockDetection) {
        state = "LOCKED";
    } else if (lockQuality >= 0.25) {
        state = "TRACKING";
    } else if (lockQuality < 0.01) {
        state = "NONE";
    }
    return { state: state, quality: lockQuality };
};

ImprovedSensorMath.computeHitProbability = function(baseAccuracy, distanceM, targetAngularVel, trackingSpeed) {
    baseAccuracy = Math.max(0, Math.min(1, baseAccuracy));
    trackingSpeed = Math.max(0.01, trackingSpeed || 0.05);
    const distanceKm = Math.max(0, distanceM) / 1000;
    const effectiveWeaponRange = CONFIG.get('MATH_WEAPON_RANGE');
    const trackingSteepness = CONFIG.get('MATH_TRACKING_STEEP');
    
    const distanceFactor = FastMath.inverseSquareFalloff(distanceKm, effectiveWeaponRange);
    const angularRatio = targetAngularVel / trackingSpeed;
    const trackingFactor = 1 - FastMath.fastSigmoid(trackingSteepness * (angularRatio - 1));
    
    return baseAccuracy * distanceFactor * trackingFactor;
};

ImprovedSensorMath.computeWeaponRange = function(baseAccuracy, hitThreshold) {
    hitThreshold = ImprovedSensorMath.clamp(hitThreshold || 0.5, 0.01, 1);
    baseAccuracy = ImprovedSensorMath.clamp(baseAccuracy, 0.01, 1);
    const ratio = hitThreshold / baseAccuracy;
    if (ratio >= 1) return 0;
    
    const effectiveRange = 15; // km
    const sqrtArg = (1 / ratio) - 1;
    if (sqrtArg < 0) return 0;
    
    PERF_COUNTERS.sqrtCalls++;
    const distKm = effectiveRange * Math.sqrt(sqrtArg);
    return Math.max(0, distKm * 1000);
};

ImprovedSensorMath.clusterTargets = function(targets, clusterRadius){
    PERF_COUNTERS.clusterOperations++;
    
    clusterRadius = Math.max(100, clusterRadius || 5000);
    const COMPRESSION_FACTOR = 0.85;
    
    if (targets.length === 0) return [];
    
    const grid = new SpatialHashGrid(clusterRadius);
    targets.forEach((t, idx) => {
        grid.insert(idx, t.x || 0, t.y || 0);
    });
    
    const clusters = [];
    const claimed = new Array(targets.length).fill(false);

    for(let i=0; i<targets.length; i++){
        if(claimed[i]) continue;
        
        const t = targets[i];
        const cluster = {
            members: [i],
            total_sig: (t.signature || 0),
            weighted_pos_x: (t.x || 0) * (t.signature || 1),
            weighted_pos_y: (t.y || 0) * (t.signature || 1),
            weighted_pos_z: (t.z || 0) * (t.signature || 1)
        };
        claimed[i] = true;

        const nearbyIndices = grid.queryRadius(t.x || 0, t.y || 0, clusterRadius);
        
        for(let j of nearbyIndices){
            if(i===j || claimed[j]) continue;
            const other = targets[j];
            const dx = (t.x||0) - (other.x||0);
            const dy = (t.y||0) - (other.y||0);
            const dz = (t.z||0) - (other.z||0);
            
            PERF_COUNTERS.sqrtCalls++;
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
            
            if(dist <= clusterRadius){
                cluster.members.push(j);
                cluster.total_sig += (other.signature || 0);
                cluster.weighted_pos_x += (other.x||0) * (other.signature || 1);
                cluster.weighted_pos_y += (other.y||0) * (other.signature || 1);
                cluster.weighted_pos_z += (other.z||0) * (other.signature || 1);
                claimed[j] = true;
            }
        }

        const count = cluster.members.length;
        const display_sig = cluster.total_sig * (count>1 ? COMPRESSION_FACTOR : 1.0);
        let pos_x = 0, pos_y = 0, pos_z = 0;
        if(cluster.total_sig > 0){
            pos_x = cluster.weighted_pos_x / cluster.total_sig;
            pos_y = cluster.weighted_pos_y / cluster.total_sig;
            pos_z = cluster.weighted_pos_z / cluster.total_sig;
        }
        clusters.push({
            x: pos_x,
            y: pos_y,
            z: pos_z,
            signature: display_sig,
            count: count,
            members: cluster.members.map(idx => targets[idx])
        });
    }
    return clusters;
};

// =========================================================================
// STABLE ID GENERATOR
// =========================================================================
const IDGenerator = {
    _counter: 1,
    next: function() {
        return this._counter++;
    },
    reset: function() {
        this._counter = 1;
    }
};

// =========================================================================
// DOM ELEMENT CACHE
// =========================================================================
const DOM = {
    canvas: null,
    ctx: null,
    hudPlayerPos: null,
    hudPlayerState: null,
    hudContacts: null,
    hudLockOutgoing: null,
    hudLockIncoming: null,
    hudSelection: null,
    threatWarning: null,
    rangeLegend: null,
    playerShipType: null,
    playerProfileDesc: null,
    playerVel: null,
    playerVelNum: null,
    playerHead: null,
    playerHeadNum: null,
    playerWeapons: null,
    playerSensorPower: null,
    playerSensorPowerNum: null,
    selectionPanel: null,
    selId: null,
    selShipType: null,
    selTeam: null,
    selVelNum: null,
    selHeadNum: null,
    selWeapons: null,
    selSensorMode: null,
    selSensorPowerNum: null,
    selEcmNum: null,
    infoSig: null,
    infoActivity: null,
    infoDetection: null,
    entityList: null,
    logPanel: null,
    zoomSlider: null,
    zoomVal: null,
    debugToggle: null,
    debugModeSelect: null,
    showRangeRings: null,
    showRangeLegend: null,
    
    init: function() {
        this.canvas = document.getElementById('main-canvas');
        this.ctx = this.canvas.getContext('2d');
        
        this.hudPlayerPos = document.getElementById('hud-player-pos');
        this.hudPlayerState = document.getElementById('hud-player-state');
        this.hudContacts = document.getElementById('hud-contacts');
        this.hudLockOutgoing = document.getElementById('hud-lock-outgoing');
        this.hudLockIncoming = document.getElementById('hud-lock-incoming');
        this.hudSelection = document.getElementById('hud-selection');
        this.threatWarning = document.getElementById('threat-warning');
        this.rangeLegend = document.getElementById('range-legend');
        
        this.playerShipType = document.getElementById('player-ship-type');
        this.playerProfileDesc = document.getElementById('player-profile-description');
        this.playerVel = document.getElementById('player-vel');
        this.playerVelNum = document.getElementById('player-vel-num');
        this.playerHead = document.getElementById('player-head');
        this.playerHeadNum = document.getElementById('player-head-num');
        this.playerWeapons = document.getElementById('player-weapons');
        this.playerSensorPower = document.getElementById('player-sensor-power');
        this.playerSensorPowerNum = document.getElementById('player-sensor-power-num');
        
        this.selectionPanel = document.getElementById('selection-panel');
        this.selId = document.getElementById('sel-id');
        this.selShipType = document.getElementById('sel-ship-type');
        this.selTeam = document.getElementById('sel-team');
        this.selVelNum = document.getElementById('sel-vel-num'); // SMALL FIX #2
        this.selHeadNum = document.getElementById('sel-head-num'); // SMALL FIX #2
        this.selWeapons = document.getElementById('sel-weapons');
        this.selSensorMode = document.getElementById('sel-sensor-mode');
        this.selSensorPowerNum = document.getElementById('sel-sensor-power-num'); // SMALL FIX #2
        this.selEcmNum = document.getElementById('sel-ecm-num'); // SMALL FIX #2
        this.infoSig = document.getElementById('info-sig');
        this.infoActivity = document.getElementById('info-activity');
        this.infoDetection = document.getElementById('info-detection');
        
        this.entityList = document.getElementById('entity-list');
        this.logPanel = document.getElementById('log-panel');
        this.zoomSlider = document.getElementById('zoom-slider');
        this.zoomVal = document.getElementById('zoom-val');
        this.debugToggle = document.getElementById('debug-toggle');
        this.debugModeSelect = document.getElementById('debug-mode-select');
        this.showRangeRings = document.getElementById('show-range-rings');
        this.showRangeLegend = document.getElementById('show-range-legend');
    }
};

// =========================================================================
// APP CONFIGURATION (with unit comments)
// =========================================================================

const CONFIG = {
    SENSOR_STRENGTH: { name: 'Sensor Power', val: 70, min: 10, max: 200, step: 10, cat: 'sys', unit: 'score' },
    DETECT_THRESH: { name: 'Detect Threshold', val: 15, min: 5, max: 50, step: 5, cat: 'sys', unit: 'score' },
    TRACKING_SPEED: { name: 'Tracking Speed', val: 0.2, min: 0.01, max: 0.5, step: 0.01, cat: 'sys', unit: 'rad/s' },
    ECM_SCALE: { name: 'ECM Scale', val: 0.05, min: 0.01, max: 0.2, step: 0.01, cat: 'sys', unit: 'multiplier' },
    WEAPON_ACCURACY: { name: 'Base Accuracy', val: 0.85, min: 0.1, max: 1.0, step: 0.05, cat: 'sys', unit: 'probability' },
    WEAPON_TRACKING: { name: 'Weapon Tracking', val: 0.05, min: 0.01, max: 0.2, step: 0.01, cat: 'sys', unit: 'rad/s' },
    CLUSTER_RAD: { name: 'Cluster Radius', val: 5000, min: 1000, max: 20000, step: 500, cat: 'sys', unit: 'meters' },    
    MATH_VEL_WEIGHT: { name: 'Velocity Weight', val: 1.0, min: 0.1, max: 3.0, step: 0.1, cat: 'math', unit: 'multiplier' },
    MATH_WEAPON_WEIGHT: { name: 'Weapon Weight', val: 0.8, min: 0.1, max: 2.0, step: 0.1, cat: 'math', unit: 'multiplier' },
    MATH_RADAR_WEIGHT: { name: 'Radar Weight', val: 0.5, min: 0.1, max: 2.0, step: 0.1, cat: 'math', unit: 'multiplier' },
    MATH_SENSITIVITY: { name: 'Activity Sensitivity', val: 1.5, min: 0.5, max: 4.0, step: 0.1, cat: 'math', unit: 'multiplier' },
    MATH_SIG_K: { name: 'Signature Curve (k)', val: 9.0, min: 1.0, max: 20.0, step: 0.5, cat: 'math', unit: 'dimensionless' },
    MATH_EFFECTIVE_RANGE: { name: 'Effective Range', val: 30, min: 10, max: 200, step: 5, cat: 'math', unit: 'km' },
    MATH_PEAK_SCORE: { name: 'Peak Score', val: 140, min: 50, max: 500, step: 10, cat: 'math', unit: 'score' },
    MATH_REF_STRENGTH: { name: 'Reference Strength', val: 100, min: 10, max: 500, step: 10, cat: 'math', unit: 'score' },
    MATH_MIN_DETECTION: { name: 'Min Detection Lock', val: 10, min: 5, max: 50, step: 5, cat: 'math', unit: 'score' },
    MATH_FULL_LOCK_DETECT: { name: 'Full Lock Detection', val: 30, min: 30, max: 100, step: 5, cat: 'math', unit: 'score' },
    MATH_OPTIMAL_TRACK_TIME: { name: 'Optimal Track Time', val: 2.0, min: 0.5, max: 10.0, step: 0.5, cat: 'math', unit: 'seconds' },
    MATH_MAX_ANG_PENALTY: { name: 'Max Angular Penalty', val: 0.3, min: 0.1, max: 1.0, step: 0.05, cat: 'math', unit: 'fraction' },
    MATH_WEAPON_RANGE: { name: 'Weapon Range', val: 20, min: 5, max: 100, step: 5, cat: 'math', unit: 'km' },
    MATH_TRACKING_STEEP: { name: 'Tracking Steepness', val: 2.0, min: 0.5, max: 5.0, step: 0.1, cat: 'math', unit: 'dimensionless' },
    
    get: function(key) {
        const cfg = this[key];
        if (!cfg) return 0;
        return ImprovedSensorMath.clamp(cfg.val, cfg.min, cfg.max);
    }
};

// =========================================================================
// APP STATE
// =========================================================================

const STATE = {
    player: null,
    targets: [],
    outgoingLock: { targetId: null, trackingTime: 0, status: 'NONE', quality: 0, prevStatus: 'NONE' },
    incomingLocks: [],
    selectedId: null,
    playing: true,
    zoom: 0.15, // SMALL FIX #4: default zoom 2x further out (was 0.3)
    panX: 0,
    panY: 0,
    defaultShipType: "Heavy Frigate",
    defaultTeam: "player",
    debugMode: 'off', // 'off', 'perf', 'heavy'
    showRangeRings: true,
    showRangeLegend: true,
    playerBeingLocked: false,
    _hudUpdateCounter: 0,
    _hudUpdateInterval: 3,
    _last_dt: 0.016
};

// =========================================================================
// PLAYER CLASS (SMALL FIX #1: homogenized detection logic)
// =========================================================================

class Player {
    constructor(shipType) {
        this.id = IDGenerator.next();
        this.shipType = shipType || "Heavy Frigate";
        
        // Position
        this.x = 0;
        this.y = 0;
        this.z = 0;
        
        // Velocity
        this.speed = 0;      // m/s
        this.heading = 0;    // radians
        this.vx = 0;         // m/s
        this.vy = 0;         // m/s
        this.vz = 0;         // m/s
        
        // Activity
        this.weaponsFiring = false;
        this.radarActive = true;
        
        // Sensor mode
        this.sensorMode = 'Active';
        this.sensorPower = 1.0;  // multiplier
        
        // Computed (SMALL FIX #1: same as targets)
        this.signature = 0;       // dimensionless score
        this.activityLevel = 0;   // 0-1 fraction
        this.detected = false;    // SMALL FIX #1: player can be detected by enemies
        this.detectionScore = 0;  // SMALL FIX #1: player has detection score
        
        // Team
        this.team = 'player';
    }
    
    getSizeClass() {
        return ImprovedSensorMath.getShipProfile(this.shipType).size;
    }
    
    updateVelocity() {
        this.vx = Math.cos(this.heading) * this.speed;
        this.vy = Math.sin(this.heading) * this.speed;
        this.vz = 0;
    }
    
    updateSignature() {
        const velocityRatio = this.speed / 200;
        this.activityLevel = ImprovedSensorMath.computeActivityLevel(
            velocityRatio,
            this.weaponsFiring,
            this.radarActive
        );
        this.signature = ImprovedSensorMath.computeSignature(this.shipType, this.activityLevel);
    }
    
    update(dt) {
        this.updateVelocity();
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.updateSignature();
    }
}

// =========================================================================
// TARGET CLASS
// =========================================================================

class Target {
    constructor(id, x, y, shipType) {
        this.id = id;
        this.x = x;                           // meters
        this.y = y;                           // meters
        this.z = 0;                           // meters
        this.speed = 50;                      // m/s
        this.heading = 0;                     // radians
        this.shipType = shipType || STATE.defaultShipType;
        this.weaponsFiring = false;
        this.radarActive = true;
        this.ecm = 0;                         // dimensionless level
        this.team = STATE.defaultTeam;
        this.sensorMode = 'Active';
        this.sensorPower = 1.0;               // multiplier
        
        // Computed
        this.signature = 0;                   // dimensionless score
        this.activityLevel = 0;               // 0-1 fraction
        this.detected = false;
        this.detectionScore = 0;              // dimensionless score
        this.trackingQuality = 0;             // 0-1 fraction
        this.angularVelocity = 0;             // rad/s
        this.hitProbability = 0;              // 0-1 probability
        
        // Incoming lock tracking
        this._incomingTrackingTime = 0;       // seconds
        this._prevIncomingStatus = 'NONE';
    }
    
    getSizeClass() {
        return ImprovedSensorMath.getShipProfile(this.shipType).size;
    }
}

// =========================================================================
// MATH HELPERS (with caching)
// =========================================================================

function dist(a, b) {
    PERF_COUNTERS.distanceComputations++;
    
    const cached = DistanceCache.get(a.x, a.y, b.x, b.y);
    if (cached !== undefined) {
        return cached;
    }
    
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    PERF_COUNTERS.sqrtCalls++;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    DistanceCache.set(a.x, a.y, b.x, b.y, distance);
    
    return distance;
}

function rad(deg) { return deg * Math.PI / 180; }
function deg(rad) { return rad * 180 / Math.PI; }

// =========================================================================
// LOCK UPDATE FUNCTION
// =========================================================================

function updateLocks(){
    const out = STATE.outgoingLock;
    const target = out.targetId ? STATE.targets.find(t=>t.id === out.targetId) : null;
    if(target && target.detected && STATE.player){
        out.trackingTime += STATE._last_dt || 0.016;
        const targetVel = { x: Math.cos(target.heading)*target.speed, y: Math.sin(target.heading)*target.speed, z: 0 };
        const playerVel = { x: STATE.player.vx, y: STATE.player.vy, z: 0 };
        const angRes = ImprovedSensorMath.computeAngularVelocity({x: target.x, y: target.y, z: 0}, targetVel, {x: STATE.player.x, y: STATE.player.y, z: 0}, playerVel);
        const angVel = angRes[0];
        const lockResult = ImprovedSensorMath.computeLockState(target.detectionScore, angVel, out.trackingTime, CONFIG.get('TRACKING_SPEED'));
        out.status = lockResult.state;
        out.quality = lockResult.quality;
    } else {
        out.trackingTime = Math.max(0, out.trackingTime - (STATE._last_dt || 0.016) * 2);
        out.status = "NONE";
        out.quality = 0;
    }
    if(out.status !== out.prevStatus){
        log(`OutgoingLock: ${out.status} [${Math.round(out.quality*100)}%]`, 'LOCK', 'PLR');
        out.prevStatus = out.status;
    }

    STATE.incomingLocks = [];
    STATE.targets.forEach(src=>{
        if (src.team === STATE.player.team) return;
        
        const sourceSensorMultiplier = (src.sensorPower !== undefined) ? Number(src.sensorPower) : 1.0;
        const sourceSensorPower = CONFIG.get('SENSOR_STRENGTH') * sourceSensorMultiplier;
        const distance = dist(src, STATE.player || {x:0, y:0});
        const detectionScoreOnPlayer = ImprovedSensorMath.computeDetectionScore( STATE.player ? STATE.player.signature : 0, sourceSensorPower, distance );

        if(detectionScoreOnPlayer >= CONFIG.get('DETECT_THRESH')){
            const srcVel = { x: Math.cos(src.heading)*src.speed, y: Math.sin(src.heading)*src.speed, z: 0 };
            const playerVel = { x: STATE.player.vx, y: STATE.player.vy, z: 0 };
            const angRes = ImprovedSensorMath.computeAngularVelocity({x: STATE.player.x, y: STATE.player.y, z: 0}, playerVel, {x: src.x, y: src.y, z: 0}, srcVel);
            const angVelSrc = angRes[0];

            src._incomingTrackingTime = Math.max(0, (src._incomingTrackingTime || 0) + (STATE._last_dt || 0.016));
            const lockOnPlayer = ImprovedSensorMath.computeLockState(detectionScoreOnPlayer, angVelSrc, src._incomingTrackingTime, CONFIG.get('TRACKING_SPEED'));

            STATE.incomingLocks.push({
                sourceId: src.id,
                status: lockOnPlayer.state,
                quality: lockOnPlayer.quality,
                detectionScore: detectionScoreOnPlayer
            });

            if(src._prevIncomingStatus !== lockOnPlayer.state){
                log(`IncomingLockFrom: ${src.id} => ${lockOnPlayer.state} [${Math.round(lockOnPlayer.quality*100)}%]`, 'LOCK', 'SYS');
                src._prevIncomingStatus = lockOnPlayer.state;
            }
        } else {
            src._incomingTrackingTime = Math.max(0, (src._incomingTrackingTime || 0) - (STATE._last_dt || 0.016)*2);
            if(src._incomingTrackingTime <= 0){
                src._incomingTrackingTime = 0;
                if(src._prevIncomingStatus && src._prevIncomingStatus !== 'NONE'){
                    log(`IncomingLockFrom: ${src.id} LOST`, 'LOCK', 'SYS');
                }
                src._prevIncomingStatus = 'NONE';
            }
        }
    });

    STATE.playerBeingLocked = STATE.incomingLocks.some(l => l.status === 'LOCKED');
}

// =========================================================================
// SIMULATION LOOP
// =========================================================================

let lastTime = 0;

function loop(time) {
    requestAnimationFrame(loop);

    const dt = Math.min((time - lastTime) / 1000, 0.1);
    lastTime = time;

    if (!STATE.playing) return;

    STATE._last_dt = dt;

    if (STATE.player) {
        STATE.player.update(dt);
    }

    STATE.targets.forEach(t => {
        const vx = Math.cos(t.heading) * t.speed;
        const vy = Math.sin(t.heading) * t.speed;
        
        t.x += vx * dt;
        t.y += vy * dt;

        const velocityRatio = t.speed / 200;
        t.activityLevel = ImprovedSensorMath.computeActivityLevel(
            velocityRatio,
            t.weaponsFiring,
            t.radarActive
        );

        t.signature = ImprovedSensorMath.computeSignature(t.shipType, t.activityLevel);

        const distance = dist(t, STATE.player || {x:0, y:0});
        const effectiveSensorPower = CONFIG.get('SENSOR_STRENGTH') * (STATE.player ? STATE.player.sensorPower : 1.0);
        t.detectionScore = ImprovedSensorMath.computeDetectionScore(
            t.signature,
            effectiveSensorPower,
            distance
        );
        t.detected = ImprovedSensorMath.isDetected(t.detectionScore, CONFIG.get('DETECT_THRESH'));

        if (t.detected && STATE.player) {
            const targetVel = { x: vx, y: vy, z: 0 };
            const playerVel = { x: STATE.player.vx, y: STATE.player.vy, z: 0 };
            const playerPos = { x: STATE.player.x, y: STATE.player.y, z: 0 };
            const tgtPos = { x: t.x, y: t.y, z: 0 };

            const angRes = ImprovedSensorMath.computeAngularVelocity(tgtPos, targetVel, playerPos, playerVel);
            t.angularVelocity = angRes[0];
            
            const angVelWithECM = t.angularVelocity * (1 + t.ecm * CONFIG.get('ECM_SCALE'));
            
            t.hitProbability = ImprovedSensorMath.computeHitProbability(
                CONFIG.get('WEAPON_ACCURACY'),
                distance,
                angVelWithECM,
                CONFIG.get('WEAPON_TRACKING')
            );
        } else {
            t.angularVelocity = 0;
            t.hitProbability = 0;
        }
    });

    updateLocks();
    render();
    
    const hudInterval = STATE.debugMode === 'heavy' ? 1 : 3;
    STATE._hudUpdateCounter++;
    if (STATE._hudUpdateCounter >= hudInterval) {
        STATE._hudUpdateCounter = 0;
        updateHUD();
    }
    
    updateSelectionInfo();
}

// =========================================================================
// RENDERING
// =========================================================================

let canvasW, canvasH;

function resizeCanvas() {
    const parent = DOM.canvas.parentElement;
    const dpr = window.devicePixelRatio || 1;
    DOM.canvas.width = parent.clientWidth * dpr;
    DOM.canvas.height = parent.clientHeight * dpr;
    DOM.canvas.style.width = parent.clientWidth + 'px';
    DOM.canvas.style.height = parent.clientHeight + 'px';
    canvasW = parent.clientWidth;
    canvasH = parent.clientHeight;
    DOM.ctx.scale(dpr, dpr);
}

function render() {
    window.DEBUG_LABEL_STACK = [];

    const ctx = DOM.ctx;
    
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    const dpr = window.devicePixelRatio || 1;
    ctx.scale(dpr, dpr);
    
    // SMALL FIX #4: pure black background
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvasW, canvasH);

    const cx = canvasW / 2;
    const cy = canvasH / 2;

    ctx.save();
    
    const playerOffsetX = STATE.player ? -STATE.player.x : 0;
    const playerOffsetY = STATE.player ? -STATE.player.y : 0;
    
    ctx.translate(cx + STATE.panX, cy + STATE.panY);
    ctx.scale(STATE.zoom, STATE.zoom);
    ctx.translate(playerOffsetX, playerOffsetY);

    const lw = 1 / STATE.zoom;
    ctx.lineWidth = lw;
    
    // SMALL FIX #4: white grid overlay with low opacity
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';

    const viewLeft = (-(cx + STATE.panX) / STATE.zoom) - playerOffsetX;
    const viewTop = (-(cy + STATE.panY) / STATE.zoom) - playerOffsetY;
    const viewRight = ((canvasW - (cx + STATE.panX)) / STATE.zoom) - playerOffsetX;
    const viewBottom = ((canvasH - (cy + STATE.panY)) / STATE.zoom) - playerOffsetY;

    const gridSize = 1000;
    const startX = Math.floor(viewLeft / gridSize) * gridSize;
    const startY = Math.floor(viewTop / gridSize) * gridSize;

    ctx.beginPath();
    for (let x = startX; x < viewRight; x += gridSize) {
        ctx.moveTo(x, viewTop); ctx.lineTo(x, viewBottom);
    }
    for (let y = startY; y < viewBottom; y += gridSize) {
        ctx.moveTo(viewLeft, y); ctx.lineTo(viewRight, y);
    }
    ctx.stroke();

    // ENTITY-RELATIVE RANGE RINGS
    if (STATE.showRangeRings) {
        renderEntityRangeRings(ctx);
    }

    // Draw player
    if (STATE.player) {
        ctx.save();
        ctx.translate(STATE.player.x, STATE.player.y);
        ctx.rotate(STATE.player.heading);
        
        ctx.fillStyle = '#3fb950';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2 / STATE.zoom;
        
        // SMALL FIX #4: significantly larger ship icons
        const sizeMap = { frigate: 30, cruiser: 50, capital: 80 };
        const size = sizeMap[STATE.player.getSizeClass()] || 30;
        
        ctx.beginPath();
        ctx.moveTo(size, 0);
        ctx.lineTo(-size * 0.6, size * 0.5);
        ctx.lineTo(-size * 0.4, 0);
        ctx.lineTo(-size * 0.6, -size * 0.5);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.restore();
    }

    // Draw targets
    STATE.targets.forEach(t => {
        const isAlly = t.team === STATE.player.team;
        const isSelected = t.id === STATE.selectedId;
        
        ctx.save();
        ctx.translate(t.x, t.y);
        ctx.rotate(t.heading);
        
        // SMALL FIX #5: distinct colors for Allie/Enemy
        if (isAlly) {
            ctx.fillStyle = t.detected ? 'rgba(0, 217, 255, 0.6)' : 'rgba(0, 217, 255, 0.3)';
            ctx.strokeStyle = '#00d9ff';
        } else {
            ctx.fillStyle = t.detected ? 'rgba(255, 69, 0, 0.6)' : 'rgba(255, 69, 0, 0.3)';
            ctx.strokeStyle = '#ff4500';
        }
        
        ctx.lineWidth = isSelected ? 3 / STATE.zoom : 2 / STATE.zoom;
        
        // SMALL FIX #4: significantly larger ship icons
        const sizeMap = { frigate: 24, cruiser: 40, capital: 70 };
        const size = sizeMap[t.getSizeClass()] || 24;
        
        ctx.beginPath();
        ctx.moveTo(size, 0);
        ctx.lineTo(-size * 0.6, size * 0.5);
        ctx.lineTo(-size * 0.4, 0);
        ctx.lineTo(-size * 0.6, -size * 0.5);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.restore();
        
        // CONSOLIDATED DEBUG TELEMETRY - HEAVY MODE ONLY
        if (STATE.debugMode === 'heavy' && t.detected) {
            const label = buildDebugLabel(t);
            // SMALL FIX #11: adjust label offset for larger icons
            queueDebugLabel(t.x, t.y - (size + 15), label);
        }
    });

    // Lock indicator
    if (STATE.outgoingLock.status !== 'NONE' && STATE.outgoingLock.targetId) {
        const target = STATE.targets.find(t => t.id === STATE.outgoingLock.targetId);
        if (target && STATE.player) {
            ctx.strokeStyle = STATE.outgoingLock.status === 'LOCKED' ? '#d29922' : 'rgba(210, 153, 34, 0.5)';
            ctx.lineWidth = 2 / STATE.zoom;
            ctx.setLineDash([10 / STATE.zoom, 10 / STATE.zoom]);
            ctx.beginPath();
            ctx.moveTo(STATE.player.x, STATE.player.y);
            ctx.lineTo(target.x, target.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }

    ctx.restore();
    
    renderDebugLabels(ctx, cx, cy);
}

// =========================================================================
// ENTITY-RELATIVE RANGE RINGS (SMALL FIX #7: thicker and more visible)
// =========================================================================

function renderEntityRangeRings(ctx) {
    const playerSensorPower = CONFIG.get('SENSOR_STRENGTH') * (STATE.player ? STATE.player.sensorPower : 1.0);
    const threshold = CONFIG.get('DETECT_THRESH');
    const weaponRange = CONFIG.get('MATH_WEAPON_RANGE') * 1000; // km to m
    
    // Draw rings for each detected entity
    const entitiesToRing = [];
    
    // Add player
    if (STATE.player) {
        entitiesToRing.push({
            entity: STATE.player,
            color: 'rgba(63, 185, 80, 0.25)', // SMALL FIX #7: increased opacity
            rings: [1000, 5000, 10000] // 1km, 5km, 10km
        });
    }
    
    // Add detected targets (limit to avoid clutter)
    const maxRingedTargets = STATE.debugMode === 'heavy' ? 10 : 3;
    const detectedTargets = STATE.targets.filter(t => t.detected).slice(0, maxRingedTargets);
    
    detectedTargets.forEach(t => {
        const isAlly = t.team === STATE.player.team;
        // SMALL FIX #7: increased opacity
        entitiesToRing.push({
            entity: t,
            color: isAlly ? 'rgba(0, 217, 255, 0.2)' : 'rgba(255, 69, 0, 0.2)',
            rings: [1000, 5000, 10000]
        });
    });
    
    // Draw detection range ring for player
    if (STATE.player && STATE.debugMode === 'heavy') {
        const detectionRange = ImprovedSensorMath.computeDetectionRange(1, playerSensorPower, threshold);
        if (isFinite(detectionRange) && detectionRange > 0) {
            ctx.strokeStyle = 'rgba(63, 185, 80, 0.4)'; // SMALL FIX #7: increased opacity
            ctx.lineWidth = 3 / STATE.zoom; // SMALL FIX #7: thicker
            ctx.setLineDash([5 / STATE.zoom, 5 / STATE.zoom]);
            ctx.beginPath();
            ctx.arc(STATE.player.x, STATE.player.y, detectionRange, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
    
    // Draw weapon range ring for selected target
    if (STATE.debugMode === 'heavy' && STATE.selectedId) {
        const selected = STATE.targets.find(t => t.id === STATE.selectedId);
        if (selected && selected.detected) {
            ctx.strokeStyle = 'rgba(210, 153, 34, 0.4)'; // SMALL FIX #7: increased opacity
            ctx.lineWidth = 3 / STATE.zoom; // SMALL FIX #7: thicker
            ctx.setLineDash([3 / STATE.zoom, 7 / STATE.zoom]);
            ctx.beginPath();
            ctx.arc(selected.x, selected.y, weaponRange, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
    
    // Draw relative distance rings for each entity
    entitiesToRing.forEach(item => {
        const e = item.entity;
        ctx.strokeStyle = item.color;
        ctx.lineWidth = 2 / STATE.zoom; // SMALL FIX #7: thicker (was 1)
        
        item.rings.forEach(r => {
            ctx.beginPath();
            ctx.arc(e.x, e.y, r, 0, Math.PI * 2);
            ctx.stroke();
        });
    });
}

// =========================================================================
// CONSOLIDATED DEBUG LABEL BUILDING (HEAVY MODE ONLY)
// =========================================================================

function buildDebugLabel(target) {
    // Consolidated, non-redundant entity telemetry
    const distKm = (dist(target, STATE.player || {x:0, y:0}) / 1000).toFixed(1);
    const sig = Math.round(target.signature);
    const det = Math.round(target.detectionScore);
    const spd = Math.round(target.speed);
    const lock = target.id === STATE.outgoingLock.targetId ? `[${STATE.outgoingLock.status}]` : '';
    
    return `ID:${target.id} ${target.shipType.substring(0,8)} | ${distKm}km | S:${sig} D:${det} V:${spd}m/s ${lock}`.trim();
}

function queueDebugLabel(x, y, text) {
    if (!window.DEBUG_LABEL_STACK) window.DEBUG_LABEL_STACK = [];
    window.DEBUG_LABEL_STACK.push({ x, y, text });
}

function renderDebugLabels(ctx, cx, cy) {
    if (!window.DEBUG_LABEL_STACK || window.DEBUG_LABEL_STACK.length === 0) return;
    
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    const dpr = window.devicePixelRatio || 1;
    ctx.scale(dpr, dpr);
    
    ctx.font = '10px monospace';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
    ctx.lineWidth = 3;
    
    window.DEBUG_LABEL_STACK.forEach(label => {
        const playerOffsetX = STATE.player ? -STATE.player.x : 0;
        const playerOffsetY = STATE.player ? -STATE.player.y : 0;
        
        const screenX = cx + STATE.panX + (label.x + playerOffsetX) * STATE.zoom;
        const screenY = cy + STATE.panY + (label.y + playerOffsetY) * STATE.zoom;
        
        ctx.strokeText(label.text, screenX, screenY);
        ctx.fillText(label.text, screenX, screenY);
    });
    
    ctx.restore();
}

// =========================================================================
// HUD UPDATE
// =========================================================================

function updateHUD() {
    if (STATE.player && DOM.hudPlayerPos) {
        const px = (STATE.player.x / 1000).toFixed(1);
        const py = (STATE.player.y / 1000).toFixed(1);
        DOM.hudPlayerPos.innerText = `${px}km, ${py}km`;
    }

    if (DOM.hudContacts) {
        DOM.hudContacts.innerText = STATE.targets.length;
    }

    if (DOM.hudLockOutgoing) {
        const out = STATE.outgoingLock;
        const quality = Math.round(out.quality * 100);
        DOM.hudLockOutgoing.innerText = `${out.status} (${quality}%)`;
        DOM.hudLockOutgoing.style.color = out.status === 'LOCKED' ? '#d29922' : '#58a6ff';
    }

    if (DOM.hudLockIncoming) {
        const incoming = STATE.incomingLocks.filter(l => l.status !== 'NONE');
        if (incoming.length > 0) {
            const locked = incoming.filter(l => l.status === 'LOCKED').length;
            const tracking = incoming.filter(l => l.status === 'TRACKING' || l.status === 'ACQUIRING').length;
            DOM.hudLockIncoming.innerText = `${locked} LOCKED, ${tracking} TRACKING`;
            DOM.hudLockIncoming.style.color = locked > 0 ? '#f85149' : '#d29922';
        } else {
            DOM.hudLockIncoming.innerText = 'NONE';
            DOM.hudLockIncoming.style.color = '#3fb950';
        }
    }

    if (DOM.threatWarning) {
    // usamos clase visible/hidden en lugar de manipular directamente style.display
    DOM.threatWarning.classList.toggle('visible', !!STATE.playerBeingLocked);
    DOM.threatWarning.setAttribute('aria-hidden', STATE.playerBeingLocked ? 'false' : 'true');
}
    // si la leyenda de rango existe, la movemos hacia arriba cuando el threat sea visible
    if (DOM.rangeLegend) {
        DOM.rangeLegend.classList.toggle('shift-up', !!STATE.playerBeingLocked);
    }
    if (DOM.hudSelection && STATE.selectedId) {
        const t = STATE.targets.find(x => x.id === STATE.selectedId);
        if (t) {
            const distKm = (dist(t, STATE.player || {x:0,y:0}) / 1000).toFixed(1);
            DOM.hudSelection.innerText = `Selected: ${t.shipType} (${distKm}km)`;
        }
    } else if (DOM.hudSelection) {
        DOM.hudSelection.innerText = '';
    }
    
    refreshEntityList();
}

// =========================================================================
// INPUT HANDLERS
// =========================================================================

function setupInputHandlers() {
    let isDragging = false;
    let dragStartX = 0, dragStartY = 0;
    
    DOM.canvas.addEventListener('mousedown', (e) => {
        if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
            isDragging = true;
            dragStartX = e.clientX - STATE.panX;
            dragStartY = e.clientY - STATE.panY;
            e.preventDefault();
        } else if (e.button === 0) {
            const rect = DOM.canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            
            const cx = canvasW / 2;
            const cy = canvasH / 2;
            const playerOffsetX = STATE.player ? -STATE.player.x : 0;
            const playerOffsetY = STATE.player ? -STATE.player.y : 0;
            
            const worldX = ((mx - cx - STATE.panX) / STATE.zoom) - playerOffsetX;
            const worldY = ((my - cy - STATE.panY) / STATE.zoom) - playerOffsetY;
            
            let closestTarget = null;
            let closestDist = Infinity;
            
            STATE.targets.forEach(t => {
                const dx = t.x - worldX;
                const dy = t.y - worldY;
                const d = Math.sqrt(dx*dx + dy*dy);
                if (d < closestDist && d < 500) {
                    closestDist = d;
                    closestTarget = t;
                }
            });
            
            if (closestTarget) {
                selectTarget(closestTarget.id);
            }
        }
    });
    
    DOM.canvas.addEventListener('mousemove', (e) => {
        if (isDragging) {
            STATE.panX = e.clientX - dragStartX;
            STATE.panY = e.clientY - dragStartY;
        }
    });
    
    DOM.canvas.addEventListener('mouseup', () => {
        isDragging = false;
    });
    
    DOM.canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
        STATE.zoom = ImprovedSensorMath.clamp(STATE.zoom * zoomFactor, 0.05, 5);
        DOM.zoomSlider.value = STATE.zoom;
        DOM.zoomVal.innerText = STATE.zoom.toFixed(2);
    });
    
    DOM.zoomSlider.addEventListener('input', (e) => {
        STATE.zoom = parseFloat(e.target.value);
        DOM.zoomVal.innerText = STATE.zoom.toFixed(2);
    });
    
    DOM.debugToggle.addEventListener('change', (e) => {
        if (e.target.checked && STATE.debugMode === 'off') {
            STATE.debugMode = 'perf';
            DOM.debugModeSelect.value = 'perf';
        } else if (!e.target.checked) {
            STATE.debugMode = 'off';
            DOM.debugModeSelect.value = 'off';
        }
        document.getElementById('btn-debug').classList.toggle('mode-active', e.target.checked);
    });
    
    DOM.debugModeSelect.addEventListener('change', (e) => {
        STATE.debugMode = e.target.value;
        DOM.debugToggle.checked = STATE.debugMode !== 'off';
        document.getElementById('btn-debug').classList.toggle('mode-active', STATE.debugMode !== 'off');
    });
    
    DOM.showRangeRings.addEventListener('change', (e) => {
        STATE.showRangeRings = e.target.checked;
    });
    
    DOM.showRangeLegend.addEventListener('change', (e) => {
        STATE.showRangeLegend = e.target.checked;
        if (DOM.rangeLegend) {
            DOM.rangeLegend.classList.toggle('visible', e.target.checked);
        }
    });
    
    document.getElementById('btn-play').addEventListener('click', () => {
        STATE.playing = !STATE.playing;
        document.getElementById('btn-play').innerText = STATE.playing ? 'Pause' : 'Play';
    });
    
    document.getElementById('btn-step').addEventListener('click', () => {
        if (!STATE.playing) {
            loop(performance.now());
        }
    });
    
    document.getElementById('btn-reset').addEventListener('click', resetSim);
    document.getElementById('btn-spawn').addEventListener('click', spawnTarget);
    document.getElementById('btn-debug').addEventListener('click', () => {
        DOM.debugToggle.checked = !DOM.debugToggle.checked;
        DOM.debugToggle.dispatchEvent(new Event('change'));
    });
    
    // SMALL FIX #9: Import State button opens modal
    document.getElementById('btn-test-preset').addEventListener('click', () => {
        document.getElementById('import-modal').style.display = 'flex';
    });
    
    document.getElementById('btn-assumptions').addEventListener('click', () => {
        document.getElementById('assumptions-modal').style.display = 'flex';
    });
    
    document.getElementById('btn-export').addEventListener('click', exportState);
    document.getElementById('btn-run-tests').addEventListener('click', runPerfTests);
    
    // SMALL FIX #9: Import confirm handler
    document.getElementById('btn-import-confirm').addEventListener('click', importState);
    
    // SMALL FIX #3: Save custom profile handler
    document.getElementById('btn-save-profile').addEventListener('click', saveCustomProfile);
    
    createDualInputSync(DOM.playerVel, DOM.playerVelNum, (val) => {
        if (STATE.player) {
            STATE.player.speed = val;
        }
    });
    
    createDualInputSync(DOM.playerHead, DOM.playerHeadNum, (val) => {
        if (STATE.player) {
            STATE.player.heading = rad(val);
        }
    });
    
    DOM.playerWeapons.addEventListener('change', (e) => {
        if (STATE.player) {
            STATE.player.weaponsFiring = e.target.checked;
        }
    });
    
    document.getElementById('btn-sensor-active').addEventListener('click', () => {
        if (STATE.player) {
            STATE.player.sensorMode = 'Active';
            updateSensorModeButtons();
        }
    });
    
    document.getElementById('btn-sensor-passive').addEventListener('click', () => {
        if (STATE.player) {
            STATE.player.sensorMode = 'Passive';
            updateSensorModeButtons();
        }
    });
    
    createDualInputSync(DOM.playerSensorPower, DOM.playerSensorPowerNum, (val) => {
        if (STATE.player) {
            STATE.player.sensorPower = val;
        }
    });
    
    DOM.playerShipType.addEventListener('change', (e) => {
        if (STATE.player) {
            STATE.player.shipType = e.target.value;
            const profile = ImprovedSensorMath.getShipProfile(e.target.value);
            DOM.playerProfileDesc.textContent = profile.description;
            log(`Player ship type changed to ${e.target.value}`, 'INFO', 'PLR');
        }
    });
    
    document.getElementById('default-ship-profile').addEventListener('change', (e) => {
        STATE.defaultShipType = e.target.value;
        const profile = ImprovedSensorMath.getShipProfile(e.target.value);
        document.getElementById('profile-description').textContent = profile.description;
    });
    
    document.getElementById('default-team').addEventListener('change', (e) => {
        STATE.defaultTeam = e.target.value;
    });
}

function updateSensorModeButtons() {
    const active = document.getElementById('btn-sensor-active');
    const passive = document.getElementById('btn-sensor-passive');
    
    if (STATE.player && STATE.player.sensorMode === 'Active') {
        active.classList.add('mode-active');
        passive.classList.remove('mode-active');
    } else {
        active.classList.remove('mode-active');
        passive.classList.add('mode-active');
    }
}

function createDualInputSync(sliderElem, numberElem, callback) {
    const sync = (val) => {
        val = parseFloat(val);
        sliderElem.value = val;
        numberElem.value = val;
        if (callback) callback(val);
    };
    
    sliderElem.addEventListener('input', (e) => sync(e.target.value));
    numberElem.addEventListener('input', (e) => sync(e.target.value));
}

// SMALL FIX #3: Save custom ship profile
function saveCustomProfile() {
    const name = document.getElementById('custom-profile-name').value.trim();
    const sig = parseFloat(document.getElementById('custom-profile-sig').value);
    const gain = parseFloat(document.getElementById('custom-profile-gain').value);
    const size = document.getElementById('custom-profile-size').value;
    const desc = document.getElementById('custom-profile-desc').value.trim();
    
    if (!name) {
        alert('Please enter a profile name');
        return;
    }
    
    const profile = {
        baseSignature: sig,
        activityGain: gain,
        size: size,
        description: desc || 'Custom profile'
    };
    
    if (ImprovedSensorMath.saveCustomProfile(name, profile)) {
        log(`Custom profile "${name}" saved`, 'INFO', 'SYS');
        populateShipSelects();
        document.getElementById('custom-profile-name').value = '';
        document.getElementById('custom-profile-sig').value = '20';
        document.getElementById('custom-profile-gain').value = '1.5';
        document.getElementById('custom-profile-desc').value = '';
    } else {
        alert('Failed to save profile');
    }
}

// =========================================================================
// UI INITIALIZATION
// =========================================================================

function populateConfigControls() {
    const containers = {
        'sys': document.getElementById('params-detection-container'),
        'math': document.getElementById('params-math-container')
    };
    
    const trackingContainer = document.getElementById('params-tracking-container');
    const weaponContainer = document.getElementById('params-weapon-container');
    
    Object.keys(CONFIG).forEach(key => {
        if (key === 'get') return;
        
        const cfg = CONFIG[key];
        let container;
        
        if (key.includes('TRACKING') || key.includes('LOCK') || key.includes('ECM')) {
            container = trackingContainer;
        } else if (key.includes('WEAPON') || key.includes('ACCURACY')) {
            container = weaponContainer;
        } else if (cfg.cat === 'sys' && !key.includes('CLUSTER')) {
            container = containers['sys'];
        } else {
            container = containers['math'];
        }
        
        if (!container) return;
        
        const group = document.createElement('div');
        group.className = 'control-group';
        
        const label = document.createElement('label');
        const unitText = cfg.unit ? ` (${cfg.unit})` : '';
        label.innerHTML = `<span class="tag tag-sys">SYS</span>${cfg.name}${unitText}`;
        
        const input = document.createElement('input');
        input.type = 'range';
        input.min = cfg.min;
        input.max = cfg.max;
        input.step = cfg.step;
        input.value = cfg.val;
        
        const valDisplay = document.createElement('span');
        valDisplay.className = 'val-display';
        valDisplay.innerText = cfg.val.toFixed(2);
        
        input.addEventListener('input', (e) => {
            cfg.val = parseFloat(e.target.value);
            valDisplay.innerText = cfg.val.toFixed(2);
        });
        
        group.appendChild(label);
        group.appendChild(input);
        group.appendChild(valDisplay);
        container.appendChild(group);
    });
}

function populateShipSelects() {
    const shipTypes = ImprovedSensorMath.getAvailableShipTypes();
    const selects = [DOM.playerShipType, document.getElementById('sel-ship-type'), document.getElementById('default-ship-profile')];
    
    selects.forEach(select => {
        if (!select) return;
        const currentValue = select.value;
        select.innerHTML = '';
        shipTypes.forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = type;
            select.appendChild(option);
        });
        if (currentValue && shipTypes.includes(currentValue)) {
            select.value = currentValue;
        }
    });
    
    if (DOM.playerShipType && !DOM.playerShipType.value) {
        DOM.playerShipType.value = "Heavy Frigate";
        const profile = ImprovedSensorMath.getShipProfile("Heavy Frigate");
        if (DOM.playerProfileDesc) DOM.playerProfileDesc.textContent = profile.description;
    }
    
    const defaultSelect = document.getElementById('default-ship-profile');
    if (defaultSelect && !defaultSelect.value) {
        defaultSelect.value = STATE.defaultShipType;
    }
    const defaultProfile = ImprovedSensorMath.getShipProfile(STATE.defaultShipType);
    document.getElementById('profile-description').textContent = defaultProfile.description;
}

function initUI() {
    DOM.init();
    
    // SMALL FIX #3: Load custom profiles from localStorage
    ImprovedSensorMath.loadCustomProfiles();
    
    populateConfigControls();
    populateShipSelects();
    
    // SMALL FIX #2: Number-only inputs (no sliders in selection panel)
    DOM.selVelNum.addEventListener('input', (e) => {
        const t = STATE.targets.find(x => x.id === STATE.selectedId);
        if (t) {
            t.speed = parseInt(e.target.value) || 0;
            log(`Target ${t.id} velocity: ${t.speed} m/s`, 'INFO', 'TGT');
        }
    });
    
    DOM.selHeadNum.addEventListener('input', (e) => {
        const t = STATE.targets.find(x => x.id === STATE.selectedId);
        if (t) {
            t.heading = rad(parseInt(e.target.value) || 0);
            log(`Target ${t.id} heading: ${e.target.value}°`, 'INFO', 'TGT');
        }
    });
    
    DOM.selShipType.addEventListener('change', (e) => {
        const t = STATE.targets.find(x => x.id === STATE.selectedId);
        if (t) {
            t.shipType = e.target.value;
            log(`Target ${t.id} ship type: ${e.target.value}`, 'INFO', 'TGT');
        }
    });
    
    DOM.selSensorPowerNum.addEventListener('input', (e) => {
        const t = STATE.targets.find(x => x.id === STATE.selectedId);
        if (t) {
            t.sensorPower = parseFloat(e.target.value) || 1.0;
            log(`Target ${t.id} sensor power: ${t.sensorPower.toFixed(1)}x`, 'INFO', 'TGT');
        }
    });
    
    DOM.selEcmNum.addEventListener('input', (e) => {
        const t = STATE.targets.find(x => x.id === STATE.selectedId);
        if (t) {
            t.ecm = parseFloat(e.target.value) || 0;
            log(`Target ${t.id} ECM: ${t.ecm}`, 'INFO', 'TGT');
        }
    });

    DOM.selWeapons.addEventListener('change', (e) => {
        const t = STATE.targets.find(x => x.id === STATE.selectedId);
        if (t) {
            t.weaponsFiring = e.target.checked;
            log(`Target ${t.id} weapons: ${t.weaponsFiring ? 'ON' : 'OFF'}`, 'INFO', 'TGT');
        }
    });

    DOM.selSensorMode.addEventListener('change', (e) => {
        const t = STATE.targets.find(x => x.id === STATE.selectedId);
        if (t) {
            t.sensorMode = e.target.value;
            log(`Target ${t.id} sensor mode: ${t.sensorMode}`, 'INFO', 'TGT');
        }
    });

    DOM.selTeam.addEventListener('change', (e) => {
        const t = STATE.targets.find(x => x.id === STATE.selectedId);
        if (t) {
            t.team = e.target.value;
            log(`Target ${t.id} team: ${t.team}`, 'INFO', 'TGT');
            refreshEntityList();
        }
    });
    
    setupInputHandlers();
    
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    STATE.player = new Player("Heavy Frigate");
    updateSensorModeButtons();
    log('Enhanced sensor testbed initialized with entity-relative range rings!', 'INFO', 'PLR');

    spawnTarget();
    STATE.targets[0].y = STATE.player.y - 5000;

    loop(0);
}

function updateSelectionUI() {
    const t = STATE.targets.find(x => x.id === STATE.selectedId);
    if (!t) {
        DOM.selectionPanel.style.display = 'none';
        return;
    }
    
    DOM.selectionPanel.style.display = 'block';
    DOM.selId.innerText = t.id;

    DOM.selShipType.value = t.shipType;
    DOM.selTeam.value = t.team;
    
    // SMALL FIX #2: Update number-only inputs
    DOM.selVelNum.value = Math.round(t.speed);
    DOM.selHeadNum.value = Math.round(deg(t.heading));

    DOM.selWeapons.checked = t.weaponsFiring;
    DOM.selSensorMode.value = t.sensorMode;
    
    DOM.selSensorPowerNum.value = t.sensorPower.toFixed(1);
    DOM.selEcmNum.value = t.ecm.toFixed(1);
}

function updateSelectionInfo() {
    const t = STATE.targets.find(x => x.id === STATE.selectedId);
    if (t && DOM.infoSig) {
        DOM.infoSig.textContent = t.signature.toFixed(1);
        DOM.infoActivity.textContent = (t.activityLevel * 100).toFixed(0) + '%';
        
        try {
            const playerSensorPower = CONFIG.get('SENSOR_STRENGTH') * (STATE.player ? STATE.player.sensorPower : 1.0);
            const threshold = CONFIG.get('DETECT_THRESH');

            const range_vs_target = ImprovedSensorMath.computeDetectionRange(t.signature, playerSensorPower, threshold);
            const intrinsicRange = ImprovedSensorMath.computeDetectionRange(1, playerSensorPower, threshold);

            const score = Math.round(t.detectionScore);
            const rTarget = (range_vs_target / 1000).toFixed(1);
            const rIntr = (intrinsicRange / 1000).toFixed(1);

            DOM.infoDetection.textContent = `${score} (R:${rTarget}km) • INTR:${rIntr}km`;
            DOM.infoDetection.style.color = t.detectionScore < 50 ? '#d29922' : '#58a6ff';
            
        } catch (e) {
            DOM.infoDetection.textContent = t.detectionScore.toFixed(1);
        }
    }
}

// SMALL FIX #8: Spawn enemies 40km to the right, with default headings
function spawnTarget() {
    const id = IDGenerator.next();
    
    let offsetX, offsetY;
    if (STATE.defaultTeam === 'enemy') {
        // SMALL FIX #8: Enemies spawn ~40km to the RIGHT of player
        offsetX = 40000 + (Math.random() - 0.5) * 5000;
        offsetY = (Math.random() - 0.5) * 5000;
    } else {
        offsetX = (Math.random() - 0.5) * 10000;
        offsetY = (Math.random() - 0.5) * 10000 - 5000;
    }
    
    const t = new Target(
        id,
        STATE.player.x + offsetX,
        STATE.player.y + offsetY,
        STATE.defaultShipType
    );
    t.speed = 50 + Math.random() * 50;
    
    // SMALL FIX #8: Default headings - Allies RIGHT (0°), Enemies LEFT (180°)
    if (STATE.defaultTeam === 'player') {
        t.heading = 0; // RIGHT
    } else {
        t.heading = Math.PI; // LEFT
    }
    
    t.team = STATE.defaultTeam;
    STATE.targets.push(t);
    selectTarget(id);
    log(`Spawned ${t.shipType} (ID: ${id}, Team: ${t.team})`, 'INFO', STATE.defaultTeam === 'player' ? 'ALLIE' : 'ENEMY');
}

function resetSim() {
    STATE.targets = [];
    STATE.outgoingLock = { targetId: null, trackingTime: 0, status: 'NONE', quality: 0, prevStatus: 'NONE' };
    STATE.incomingLocks = [];
    IDGenerator.reset();
    DistanceCache.clear();
    
    if (STATE.player) {
        STATE.player.x = 0;
        STATE.player.y = 0;
        STATE.player.speed = 0;
        STATE.player.heading = 0;
        STATE.player.weaponsFiring = false;
        STATE.player.radarActive = true;
        STATE.player.sensorMode = 'Active';
        STATE.player.sensorPower = 1.0;
        
        DOM.playerVel.value = 0;
        DOM.playerVelNum.value = 0;
        DOM.playerHead.value = 0;
        DOM.playerHeadNum.value = 0;
        DOM.playerWeapons.checked = false;
        DOM.playerSensorPower.value = 1.0;
        DOM.playerSensorPowerNum.value = 1.0;
        updateSensorModeButtons();
    }
    
    log('Simulation reset', 'WARN', 'SYS');
    spawnTarget();
}

function selectTarget(id) {
    STATE.selectedId = id;

    if (STATE.outgoingLock.targetId !== id) {
        STATE.outgoingLock.targetId = id;
        STATE.outgoingLock.trackingTime = 0;
        log(`Targeting ID ${id}`, 'INFO', 'SYS');
    }

    updateSelectionUI();
    updateSelectionInfo();

    document.querySelectorAll('.entity-item').forEach(el => el.classList.remove('active-entity'));
    const item = document.getElementById(`ent-${id}`);
    if (item) item.classList.add('active-entity');
}

function refreshEntityList() {
    if (!DOM.entityList) return;
    
    DOM.entityList.innerHTML = '';
    STATE.targets.forEach(t => {
        const div = document.createElement('div');
        div.className = `entity-item ${t.id === STATE.selectedId ? 'active-entity' : ''}`;
        div.id = `ent-${t.id}`;

        const isAlly = t.team === STATE.player.team;
        // SMALL FIX #5: Allie/Enemy tags
        let tagCls = isAlly ? 'tag-allie' : 'tag-enemy';
        let tagTxt = isAlly ? 'ALLIE' : 'ENEMY';

        const distanceKm = (dist(t, STATE.player || {x:0,y:0})/1000).toFixed(1);
        div.innerHTML = `<span class="tag ${tagCls}">${tagTxt}</span> <span>${t.shipType.substring(0, 12)}</span> <span>${distanceKm}km</span>`;
        div.onclick = () => selectTarget(t.id);
        DOM.entityList.appendChild(div);
    });
}

// SMALL FIX #9: Export full state to JSON
function exportState() {
    const exportData = {
        player: STATE.player ? {
            x: STATE.player.x,
            y: STATE.player.y,
            speed: STATE.player.speed,
            heading: STATE.player.heading,
            shipType: STATE.player.shipType,
            weaponsFiring: STATE.player.weaponsFiring,
            sensorMode: STATE.player.sensorMode,
            sensorPower: STATE.player.sensorPower
        } : null,
        targets: STATE.targets.map(t => ({
            id: t.id,
            x: t.x,
            y: t.y,
            speed: t.speed,
            heading: t.heading,
            shipType: t.shipType,
            team: t.team,
            weaponsFiring: t.weaponsFiring,
            ecm: t.ecm,
            sensorPower: t.sensorPower,
            sensorMode: t.sensorMode
        })),
        config: Object.keys(CONFIG).filter(k => k !== 'get').reduce((acc, k) => {
            acc[k] = CONFIG[k].val;
            return acc;
        }, {}),
        zoom: STATE.zoom,
        panX: STATE.panX,
        panY: STATE.panY,
        defaultShipType: STATE.defaultShipType,
        defaultTeam: STATE.defaultTeam
    };
    
    const json = JSON.stringify(exportData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'sensor_testbed_state.json';
    a.click();
    URL.revokeObjectURL(url);
    
    log('State exported to JSON', 'INFO', 'SYS');
}

// SMALL FIX #9: Import state from JSON
function importState() {
    const fileInput = document.getElementById('import-file-input');
    const file = fileInput.files[0];
    
    if (!file) {
        alert('Please select a file');
        return;
    }
    
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const data = JSON.parse(e.target.result);
            
            // Clear existing state
            STATE.targets = [];
            IDGenerator.reset();
            
            // Restore player
            if (data.player && STATE.player) {
                STATE.player.x = data.player.x || 0;
                STATE.player.y = data.player.y || 0;
                STATE.player.speed = data.player.speed || 0;
                STATE.player.heading = data.player.heading || 0;
                STATE.player.shipType = data.player.shipType || "Heavy Frigate";
                STATE.player.weaponsFiring = data.player.weaponsFiring || false;
                STATE.player.sensorMode = data.player.sensorMode || 'Active';
                STATE.player.sensorPower = data.player.sensorPower || 1.0;
                
                DOM.playerVel.value = STATE.player.speed;
                DOM.playerVelNum.value = STATE.player.speed;
                DOM.playerHead.value = deg(STATE.player.heading);
                DOM.playerHeadNum.value = deg(STATE.player.heading);
                DOM.playerWeapons.checked = STATE.player.weaponsFiring;
                DOM.playerSensorPower.value = STATE.player.sensorPower;
                DOM.playerSensorPowerNum.value = STATE.player.sensorPower;
                DOM.playerShipType.value = STATE.player.shipType;
                updateSensorModeButtons();
            }
            
            // Restore targets
            if (data.targets && Array.isArray(data.targets)) {
                data.targets.forEach(tData => {
                    const t = new Target(
                        IDGenerator.next(),
                        tData.x || 0,
                        tData.y || 0,
                        tData.shipType || "Heavy Frigate"
                    );
                    t.speed = tData.speed || 50;
                    t.heading = tData.heading || 0;
                    t.team = tData.team || "player";
                    t.weaponsFiring = tData.weaponsFiring || false;
                    t.ecm = tData.ecm || 0;
                    t.sensorPower = tData.sensorPower || 1.0;
                    t.sensorMode = tData.sensorMode || 'Active';
                    STATE.targets.push(t);
                });
            }
            
            // Restore config
            if (data.config) {
                Object.keys(data.config).forEach(k => {
                    if (CONFIG[k]) {
                        CONFIG[k].val = data.config[k];
                    }
                });
            }
            
            // Restore view
            if (data.zoom !== undefined) {
                STATE.zoom = data.zoom;
                DOM.zoomSlider.value = STATE.zoom;
                DOM.zoomVal.innerText = STATE.zoom.toFixed(2);
            }
            if (data.panX !== undefined) STATE.panX = data.panX;
            if (data.panY !== undefined) STATE.panY = data.panY;
            if (data.defaultShipType) STATE.defaultShipType = data.defaultShipType;
            if (data.defaultTeam) STATE.defaultTeam = data.defaultTeam;
            
            document.getElementById('import-modal').style.display = 'none';
            log('State imported from JSON', 'INFO', 'SYS');
            
        } catch (err) {
            console.error('Import error:', err);
            alert('Failed to import state: ' + err.message);
        }
    };
    
    reader.readAsText(file);
}

function log(msg, type='INFO', tag='') {
    if (!DOM.logPanel) return;
    
    const entry = document.createElement('div');
    entry.className = 'log-entry';
    const time = new Date().toISOString().substr(11, 8);
    const tagHtml = tag ? `<span class="log-tag">[${tag}]</span>` : '';
    entry.innerHTML = `<span class="log-time">[${time}]</span>${tagHtml}<span class="log-type-${type}">${type}</span>: ${msg}`;
    DOM.logPanel.prepend(entry);
    if (DOM.logPanel.childNodes.length > 50) DOM.logPanel.lastChild.remove();
}

// =========================================================================
// PERFORMANCE TEST HARNESS (SMALL FIX #10: exactly 19 allies + 20 enemies)
// =========================================================================

function runPerfTests() {
    log('Starting performance test harness...', 'INFO', 'SYS');
    
    const savedTargets = STATE.targets;
    const savedPlayer = STATE.player;
    
    PERF_COUNTERS.reset();
    
    const syntheticEntities = [];
    
    // SMALL FIX #10: Create exactly 19 allies
    for (let i = 0; i < 19; i++) {
        const entity = {
            id: i,
            x: (Math.random() - 0.5) * 100000,
            y: (Math.random() - 0.5) * 100000,
            z: 0,
            speed: Math.random() * 200,
            heading: Math.random() * Math.PI * 2,
            shipType: ["Interceptor", "Corvette", "Light Frigate", "Heavy Frigate", "Destroyer"][Math.floor(Math.random() * 5)],
            weaponsFiring: Math.random() > 0.5,
            radarActive: true,
            signature: 0,
            activityLevel: 0,
            detectionScore: 0,
            team: 'player'
        };
        syntheticEntities.push(entity);
    }
    
    // SMALL FIX #10: Create exactly 20 enemies
    for (let i = 19; i < 39; i++) {
        const entity = {
            id: i,
            x: (Math.random() - 0.5) * 100000,
            y: (Math.random() - 0.5) * 100000,
            z: 0,
            speed: Math.random() * 200,
            heading: Math.random() * Math.PI * 2,
            shipType: ["Interceptor", "Corvette", "Light Frigate", "Heavy Frigate", "Destroyer"][Math.floor(Math.random() * 5)],
            weaponsFiring: Math.random() > 0.5,
            radarActive: true,
            signature: 0,
            activityLevel: 0,
            detectionScore: 0,
            team: 'enemy'
        };
        syntheticEntities.push(entity);
    }
    
    const observer = { x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0 };
    
    const iterations = 10;
    const startTime = performance.now();
    
    for (let iter = 0; iter < iterations; iter++) {
        syntheticEntities.forEach(e => {
            const velocityRatio = e.speed / 200;
            e.activityLevel = ImprovedSensorMath.computeActivityLevel(
                velocityRatio,
                e.weaponsFiring,
                e.radarActive
            );
            
            e.signature = ImprovedSensorMath.computeSignature(e.shipType, e.activityLevel);
            
            const dx = e.x - observer.x;
            const dy = e.y - observer.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            e.detectionScore = ImprovedSensorMath.computeDetectionScore(
                e.signature,
                CONFIG.get('SENSOR_STRENGTH'),
                distance
            );
            
            const vel = { x: Math.cos(e.heading) * e.speed, y: Math.sin(e.heading) * e.speed, z: 0 };
            const pos = { x: e.x, y: e.y, z: e.z };
            ImprovedSensorMath.computeAngularVelocity(pos, vel, observer, { x: 0, y: 0, z: 0 });
        });
        
        ImprovedSensorMath.clusterTargets(syntheticEntities, CONFIG.get('CLUSTER_RAD'));
    }
    
    const endTime = performance.now();
    const totalTime = endTime - startTime;
    
    const report = PERF_COUNTERS.getReport();
    
    log(`PERF TEST COMPLETE: ${iterations} iterations, 39 entities (19 allies + 20 enemies)`, 'INFO', 'SYS');
    log(`Total time: ${totalTime.toFixed(2)}ms (${(totalTime/iterations).toFixed(2)}ms per iteration)`, 'INFO', 'SYS');
    log(`Total function calls: ${report.total_function_calls}`, 'INFO', 'SYS');
    log(`Expensive ops (tanh+exp+atan): ${report.expensive_ops}`, 'INFO', 'SYS');
    log(`Activity computations: ${report.breakdown.activity}`, 'INFO', 'SYS');
    log(`Signature computations: ${report.breakdown.signature}`, 'INFO', 'SYS');
    log(`Detection score computations: ${report.breakdown.detection}`, 'INFO', 'SYS');
    log(`sqrt calls: ${report.expensive_breakdown.sqrt}`, 'INFO', 'SYS');
    
    console.log('=== PERFORMANCE TEST REPORT ===');
    console.log('Total time:', totalTime.toFixed(2), 'ms');
    console.log('Per iteration:', (totalTime/iterations).toFixed(2), 'ms');
    console.log('Per entity per iteration:', (totalTime/(iterations*39)).toFixed(4), 'ms');
    console.log('Function calls:', report);
    
    STATE.targets = savedTargets;
    STATE.player = savedPlayer;
    
    log('Performance test complete. Check console for detailed report.', 'INFO', 'SYS');
}

// Start
initUI();

</script>

</body>
</html>
