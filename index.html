<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sensor and Lock Mechanics Sandbox v4.2</title>
<style>
:root {
--bg-color: #000000;
--panel-bg: #161b22;
--text-main: #c9d1d9;
--text-dim: #8b949e;
--accent: #58a6ff;
--danger: #f85149;
--warning: #d29922;
--success: #3fb950;
--border: #30363d;
--font-mono: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
/* Tag Colors */
        --tag-sys: #a371f7;
        --tag-tgt: #d29922;
        --tag-dmy: #3fb950;
        --tag-allie: #00d9ff;
        --tag-enemy: #ff4500;
        --tag-plr: #3fb950;
    }

    * { box-sizing: border-box; }

    body {
        margin: 0;
        padding: 0;
        background-color: var(--bg-color);
        color: var(--text-main);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    /* Layout */
    header {
        height: 40px;
        background: var(--panel-bg);
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        padding: 0 1rem;
        justify-content: space-between;
    }

    h1 { font-size: 14px; margin: 0; font-weight: 600; color: var(--accent); letter-spacing: 0.5px; }

    #workspace {
        flex: 1;
        display: flex;
        overflow: hidden;
    }

    /* Canvas Area */
    #viewport {
        flex: 1;
        position: relative;
        background-color: var(--bg-color); 
        cursor: crosshair;
        overflow: hidden;
    }

    canvas { display: block; width: 100%; height: 100%; }

    #overlay-ui {
        position: absolute;
        top: 10px;
        left: 10px;
        pointer-events: none;
        font-family: var(--font-mono);
        font-size: 11px;
        color: var(--success);
        text-shadow: 0 1px 2px black;
    }

    /* Range Legend */
    #range-legend {
        position: absolute;
        bottom: 10px;
        right: 10px;
        background: rgba(22, 27, 34, 0.95);
        border: 1px solid var(--border);
        border-radius: 4px;
        padding: 8px 12px;
        pointer-events: none;
        font-family: var(--font-mono);
        font-size: 10px;
        color: var(--text-main);
        display: none;
    }

    #range-legend.visible {
        display: block;
    }

    .legend-title {
        font-weight: bold;
        color: var(--accent);
        margin-bottom: 4px;
        font-size: 11px;
    }

    .legend-item {
        display: flex;
        align-items: center;
        margin: 2px 0;
        gap: 8px;
    }

    .legend-color {
        width: 20px;
        height: 2px;
        border-radius: 1px;
    }

    /* Controls Sidebar */
    #controls {
        width: 460px;
        background: var(--panel-bg);
        border-left: 1px solid var(--border);
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        font-size: 12px;
    }

    .panel-section {
        padding: 10px;
        border-bottom: 1px solid var(--border);
    }

    .panel-title {
        font-weight: bold;
        color: var(--text-dim);
        text-transform: uppercase;
        font-size: 10px;
        margin-bottom: 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    /* Widgets */
    .control-group {
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    label { color: var(--text-main); flex: 1; margin-right: 10px; white-space: nowrap; display: flex; align-items: center;}
    
    input[type="range"] {
        flex: 2;
        height: 4px;
        background: var(--border);
        border-radius: 2px;
        appearance: none;
    }
    input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        width: 12px;
        height: 12px;
        background: var(--accent);
        border-radius: 50%;
        cursor: pointer;
    }

    input[type="number"] {
        width: 70px;
        padding: 4px;
        background: var(--bg-color);
        color: var(--text-main);
        border: 1px solid var(--border);
        border-radius: 3px;
        font-size: 11px;
        font-family: var(--font-mono);
    }

    input[type="checkbox"] {
        cursor: pointer;
    }

    input[type="text"] {
        width: 100%;
        padding: 4px;
        background: var(--bg-color);
        color: var(--text-main);
        border: 1px solid var(--border);
        border-radius: 3px;
        font-size: 11px;
        font-family: var(--font-mono);
    }

    .val-display { width: 50px; text-align: right; color: var(--accent); font-family: var(--font-mono); font-size: 11px; }

    select {
        background: var(--border);
        color: var(--text-main);
        border: 1px solid rgba(255,255,255,0.1);
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 11px;
        flex: 1;
    }

    button {
        background: var(--border);
        color: var(--text-main);
        border: 1px solid rgba(255,255,255,0.1);
        padding: 4px 8px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 11px;
        transition: background 0.2s;
    }
    button:hover { background: #3c444d; }
    button.primary { background: var(--success); color: white; border: none; }
    button.danger { background: var(--danger); color: white; border: none; }
    
    /* Active Mode Button Style */
    button.mode-active {
        background: var(--accent);
        color: #0d1117;
        border-color: var(--accent);
        font-weight: bold;
    }

    /* Ownership Tags */
    .tag {
        font-size: 9px;
        padding: 1px 3px;
        border-radius: 3px;
        margin-right: 6px;
        font-family: var(--font-mono);
        font-weight: bold;
        color: #0d1117;
    }
    .tag-sys { background-color: var(--tag-sys); }
    .tag-tgt { background-color: var(--tag-tgt); }
    .tag-dmy { background-color: var(--tag-dmy); }
    .tag-allie { background-color: var(--tag-allie); }
    .tag-enemy { background-color: var(--tag-enemy); }
    .tag-plr { background-color: var(--tag-plr); }

    .legend-row {
        display: flex; gap: 10px; font-size: 10px; color: var(--text-dim); margin-top: 5px;
    }

    /* Logs */
    #log-panel {
        flex: 1;
        background: #000;
        font-family: var(--font-mono);
        padding: 5px;
        overflow-y: auto;
        font-size: 10px;
        border-top: 1px solid var(--border);
        max-height: 200px;
        min-height: 100px;
    }
    .log-entry { margin-bottom: 2px; border-bottom: 1px solid #111; padding-bottom: 2px; }
    .log-time { color: var(--text-dim); margin-right: 5px; }
    .log-type-INFO { color: var(--accent); }
    .log-type-LOCK { color: var(--warning); }
    .log-type-WARN { color: var(--danger); }
    .log-tag { font-weight: bold; margin-right: 4px; }

    /* Modal/Assumptions */
    .modal {
        display: none;
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.8);
        z-index: 100;
        justify-content: center;
        align-items: center;
    }
    .modal-content {
        background: var(--panel-bg);
        border: 1px solid var(--border);
        width: 700px;
        max-height: 80vh;
        overflow-y: auto;
        padding: 20px;
        border-radius: 6px;
    }
    .modal-header { font-size: 16px; margin-bottom: 15px; border-bottom: 1px solid var(--border); padding-bottom: 10px;}
    .assumption-list li { margin-bottom: 5px; color: var(--text-dim); }
    
    /* Utility classes */
    .flex-row { display: flex; gap: 5px; }
    .active-entity { border-left: 3px solid var(--accent); background: rgba(88, 166, 255, 0.1); }
    
    /* Entity List */
    #entity-list { max-height: 150px; overflow-y: auto; }
    .entity-item { 
        padding: 4px; border-bottom: 1px solid var(--border); 
        cursor: pointer; display: flex; justify-content: space-between; align-items: center;
    }
    .entity-item:hover { background: rgba(255,255,255,0.05); }
    .entity-item .delete-btn {
        padding: 2px 6px;
        font-size: 10px;
        margin-left: 5px;
    }

    /* Ship Profile Info */
    .profile-info {
        font-size: 10px;
        color: var(--text-dim);
        margin-top: 3px;
        font-style: italic;
    }

.threat-indicator {
    position: absolute;
    top: 12px;
    right: 12px;
    z-index: 200;
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 14px;
    border-radius: 8px;
    min-width: 160px;
    max-width: 360px;
    box-sizing: border-box;
    pointer-events: none;
    background: linear-gradient(180deg, rgba(20,16,16,0.70), rgba(20,16,16,0.55));
    border: 1px solid rgba(248,81,73,0.35);
    backdrop-filter: blur(6px) saturate(120%);
    color: var(--danger);
    font-family: var(--font-mono);
    font-size: 12px;
    font-weight: 700;
    text-shadow: 0 1px 0 rgba(0,0,0,0.6);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    box-shadow: 0 8px 20px rgba(0,0,0,0.6);
}

    .threat-indicator .ti-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: linear-gradient(180deg, rgba(248,81,73,1), rgba(255,120,100,1));
        color: #0d1117;
        font-size: 13px;
        flex: 0 0 20px;
        box-shadow: 0 2px 6px rgba(248,81,73,0.25);
    }

    .threat-indicator .ti-text {
        overflow: visible;
        white-space: normal;
        font-weight: 700;
        line-height: 1.1;
    }

    @media (max-width: 760px) {
        .threat-indicator {
            top: 12px;
            bottom: auto;
            left: 50%;
            right: auto;
            transform: translateX(-50%);
            max-width: 92%;
            white-space: normal;
            text-overflow: clip;
            padding: 10px 12px;
        }
    }
    .threat-indicator { display: none; }
    .threat-indicator.visible { display: flex !important; }

    #range-legend {
        transition: bottom 0.12s ease;
    }
    #range-legend.shift-up {
        bottom: 70px;
    }

    #range-legend { z-index: 150; }
    .threat-indicator { z-index: 200; }
    
    .dual-input-group {
        display: flex;
        gap: 8px;
        align-items: center;
        flex: 2;
    }

    .dual-input-group input[type="range"] {
        flex: 1;
    }

    .profile-creator {
        background: rgba(88, 166, 255, 0.05);
        border: 1px solid var(--border);
        padding: 8px;
        border-radius: 4px;
        margin-top: 8px;
    }

    .profile-creator h4 {
        margin: 0 0 8px 0;
        font-size: 11px;
        color: var(--accent);
    }

    .profile-creator .control-group {
        margin-bottom: 6px;
    }

    .profile-creator label {
        font-size: 10px;
    }

    .profile-creator input[type="number"],
    .profile-creator input[type="text"],
    .profile-creator select {
        width: 100%;
    }

    .weapon-info-panel {
        background: rgba(210, 153, 34, 0.05);
        border: 1px solid var(--border);
        padding: 8px;
        border-radius: 4px;
        margin-top: 8px;
        font-size: 10px;
    }

    .weapon-info-panel h4 {
        margin: 0 0 6px 0;
        font-size: 11px;
        color: var(--warning);
    }

    .weapon-stat {
        display: flex;
        justify-content: space-between;
        margin: 3px 0;
        padding: 2px 0;
        border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .weapon-stat-label {
        color: var(--text-dim);
    }

    .weapon-stat-value {
        color: var(--accent);
        font-family: var(--font-mono);
    }

</style>
</head>
<body>

<header>
<div style="display:flex; align-items:center; gap:15px;">
<h1>Sensor and Lock Mechanics Sandbox v4.2</h1>
<div class="flex-row">
<button id="btn-play">Pause</button>
<button id="btn-step">Step</button>
<button id="btn-reset">Reset</button>
</div>
</div>
<div class="flex-row">
<button id="btn-debug">Debug Overlays</button>
<button id="btn-test-preset">Import State</button>
<button id="btn-assumptions">System Info</button>
<button id="btn-export">Export State</button>
<button id="btn-run-tests">Run Perf Tests</button>
</div>
</header>

<div id="workspace">
<div id="viewport">
<canvas id="main-canvas"></canvas>
<div id="overlay-ui">
<div>PLAYER POS: <span id="hud-player-pos">0,0</span></div>
<div>PLAYER: <span id="hud-player-state">ACTIVE</span></div>
<div>CONTACTS: <span id="hud-contacts">0</span></div>
<div>LOCK OUT: <span id="hud-lock-outgoing">NONE (0%)</span></div>
<div>LOCK IN: <span id="hud-lock-incoming">NONE</span></div>
<div>WEAPON: <span id="hud-weapon-name">NONE</span></div>
<div>HIT PROB: <span id="hud-hit-prob">0%</span></div>
<div style="margin-top: 5px; color: var(--text-dim);" id="hud-selection"></div>
</div>
<div id="range-legend" class="visible">
    <div class="legend-title">RANGE RINGS</div>
    <div class="legend-item">
        <div class="legend-color" style="background: rgba(88, 166, 255, 0.3);"></div>
        <span>Entity Relative</span>
    </div>
    <div class="legend-item">
        <div class="legend-color" style="background: rgba(63, 185, 80, 0.3);"></div>
        <span>Player Detection Range</span>
    </div>
    <div class="legend-item">
        <div class="legend-color" style="background: rgba(210, 153, 34, 0.3);"></div>
        <span>Weapon Effective Range</span>
    </div>
</div>
<div id="threat-warning" class="threat-indicator" style="display:none;">
⚠ INCOMING LOCK DETECTED
</div>
</div>
<div id="controls">
    <div class="panel-section">
        <div class="panel-title">CONTROL LEGEND</div>
        <div class="legend-row">
            <div><span class="tag tag-sys">SYS</span>System</div>
            <div><span class="tag tag-plr">PLR</span>Player</div>
            <div><span class="tag tag-tgt">TGT</span>Target</div>
            <div><span class="tag tag-allie">ALLIE</span>Allie</div>
            <div><span class="tag tag-enemy">ENEMY</span>Enemy</div>
        </div>
    </div>

    <div class="panel-section" id="entity-control-panel">
        <div class="panel-title">ENTITY CONTROL <span id="entity-control-id">---</span></div>
        <div class="control-group">
            <label><span class="tag tag-plr">ENT</span>Ship Type</label>
            <select id="entity-ship-type">
            </select>
        </div>
        <div class="profile-info" id="entity-profile-description"></div>
        
        <div class="control-group">
            <label><span class="tag tag-plr">ENT</span>Team</label>
            <select id="entity-team">
                <option value="player">Allie Team</option>
                <option value="enemy">Enemy Team</option>
            </select>
        </div>
        
        <div class="control-group">
            <label><span class="tag tag-plr">ENT</span>Weapon</label>
            <select id="entity-weapon">
            </select>
        </div>
        
        <div class="control-group">
            <label><span class="tag tag-plr">ENT</span>Velocity (m/s)</label>
            <div class="dual-input-group">
                <input type="range" id="entity-vel" min="0" max="200" step="1" value="0">
                <input type="number" id="entity-vel-num" min="0" max="200" step="1" value="0">
            </div>
        </div>
        <div class="control-group">
            <label><span class="tag tag-plr">ENT</span>Heading (deg)</label>
            <div class="dual-input-group">
                <input type="range" id="entity-head" min="0" max="360" step="5" value="0">
                <input type="number" id="entity-head-num" min="0" max="360" step="1" value="0">
            </div>
        </div>
        <div class="control-group">
            <label><span class="tag tag-plr">ENT</span>Weapons Firing</label>
            <input type="checkbox" id="entity-weapons">
        </div>
        <div class="control-group">
            <label><span class="tag tag-plr">ENT</span>Sensor Mode</label>
            <div class="flex-row" id="sensor-mode-group">
                <button id="btn-sensor-active">Active</button>
                <button id="btn-sensor-passive">Passive</button>
            </div>
        </div>
        <div class="control-group">
            <label><span class="tag tag-plr">ENT</span>Sensor Power</label>
            <div class="dual-input-group">
                <input type="range" id="entity-sensor-power" min="0.1" max="2.0" step="0.1" value="1.0">
                <input type="number" id="entity-sensor-power-num" min="0.1" max="2.0" step="0.1" value="1.0">
            </div>
        </div>
        <div class="control-group">
            <label><span class="tag tag-plr">ENT</span>ECM Level</label>
            <div class="dual-input-group">
                <input type="range" id="entity-ecm" min="0" max="5" step="0.1" value="0">
                <input type="number" id="entity-ecm-num" min="0" max="5" step="0.1" value="0">
            </div>
        </div>
        
        <div style="margin-top:10px; padding-top:10px; border-top:1px solid var(--border); font-size:10px; color:var(--text-dim);">
            <div>Signature: <span id="info-sig" style="color:var(--accent)">0</span></div>
            <div>Activity: <span id="info-activity" style="color:var(--accent)">0%</span></div>
            <div>Detection: <span id="info-detection" style="color:var(--accent)">0</span></div>
        </div>

        <div class="weapon-info-panel" id="weapon-info-panel" style="display:none;">
            <h4>ACTIVE WEAPON</h4>
            <div class="weapon-stat">
                <span class="weapon-stat-label">Name:</span>
                <span class="weapon-stat-value" id="weapon-name-display">-</span>
            </div>
            <div class="weapon-stat">
                <span class="weapon-stat-label">Base Accuracy:</span>
                <span class="weapon-stat-value" id="weapon-accuracy-display">-</span>
            </div>
            <div class="weapon-stat">
                <span class="weapon-stat-label">Effective Range:</span>
                <span class="weapon-stat-value" id="weapon-range-display">-</span>
            </div>
            <div class="weapon-stat">
                <span class="weapon-stat-label">Tracking Speed:</span>
                <span class="weapon-stat-value" id="weapon-tracking-display">-</span>
            </div>
            <div class="weapon-stat">
                <span class="weapon-stat-label">Guidance:</span>
                <span class="weapon-stat-value" id="weapon-guidance-display">-</span>
            </div>
            <div class="weapon-stat">
                <span class="weapon-stat-label">Sensitivity:</span>
                <span class="weapon-stat-value" id="weapon-sensitivity-display">-</span>
            </div>
            <div style="margin-top:8px; padding-top:8px; border-top:1px solid var(--border);">
                <div class="weapon-stat">
                    <span class="weapon-stat-label">Distance Factor:</span>
                    <span class="weapon-stat-value" id="weapon-dist-factor">0%</span>
                </div>
                <div class="weapon-stat">
                    <span class="weapon-stat-label">Tracking Factor:</span>
                    <span class="weapon-stat-value" id="weapon-track-factor">0%</span>
                </div>
                <div class="weapon-stat">
                    <span class="weapon-stat-label">Hit Probability:</span>
                    <span class="weapon-stat-value" id="weapon-hit-prob-display">0%</span>
                </div>
            </div>
        </div>

        <div class="profile-creator">
            <h4>CREATE CUSTOM SHIP PROFILE</h4>
            <div class="control-group">
                <label>Profile Name</label>
                <input type="text" id="custom-profile-name" placeholder="e.g., Custom Fighter">
            </div>
            <div class="control-group">
                <label>Base Signature</label>
                <input type="number" id="custom-profile-sig" min="1" max="200" step="1" value="20">
            </div>
            <div class="control-group">
                <label>Activity Gain</label>
                <input type="number" id="custom-profile-gain" min="0.1" max="5.0" step="0.1" value="1.5">
            </div>
            <div class="control-group">
                <label>Size Class</label>
                <select id="custom-profile-size">
                    <option value="frigate">Frigate</option>
                    <option value="cruiser">Cruiser</option>
                    <option value="capital">Capital</option>
                </select>
            </div>
            <div class="control-group">
                <label>Description</label>
                <input type="text" id="custom-profile-desc" placeholder="Short description">
            </div>
            <button id="btn-save-profile" class="primary" style="width:100%; margin-top:5px;">Save Profile</button>
        </div>
    </div>

    <div class="panel-section">
        <div class="panel-title">SPAWN DEFAULTS</div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Default Ship Type</label>
            <select id="default-ship-profile">
            </select>
        </div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Default Team</label>
            <select id="default-team">
                <option value="player">Allie Team</option>
                <option value="enemy">Enemy Team</option>
            </select>
        </div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Default Weapon</label>
            <select id="default-weapon">
            </select>
        </div>
        <div class="profile-info" id="profile-description">
            Select a ship profile to see description
        </div>
    </div>

    <div class="panel-section">
        <div class="panel-title">DETECTION SYSTEM</div>
        <div id="params-detection-container"></div>
    </div>

    <div class="panel-section">
        <div class="panel-title">TRACKING & LOCK</div>
        <div id="params-tracking-container"></div>
    </div>

    <div class="panel-section">
        <div class="panel-title">WEAPON HIT PROBABILITY</div>
        <div id="params-weapon-container"></div>
    </div>

    <div class="panel-section">
        <div class="panel-title">ADVANCED SYSTEM MATH</div>
        <div id="params-math-container"></div>
    </div>

    <div class="panel-section">
        <div class="panel-title">PERFORMANCE & DEBUG</div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Debug Mode</label>
            <select id="debug-mode-select">
                <option value="off">Off</option>
                <option value="perf">Performance (Minimal Info)</option>
                <option value="heavy">Heavy (Full Telemetry)</option>
            </select>
        </div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Show Range Rings</label>
            <input type="checkbox" id="show-range-rings" checked>
        </div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Show Range Legend</label>
            <input type="checkbox" id="show-range-legend" checked>
        </div>
    </div>

    <div class="panel-section">
        <div class="panel-title">VIEW CONTROLS</div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Zoom Level</label>
            <div class="dual-input-group">
                <input type="range" id="zoom-slider" min="0.05" max="5" step="0.05" value="0.15">
                <input type="number" id="zoom-val-num" min="0.05" max="5" step="0.05" value="0.15">
            </div>
        </div>
        <div class="control-group">
            <label><span class="tag tag-sys">SYS</span>Debug Overlays</label>
            <input type="checkbox" id="debug-toggle">
        </div>
    </div>

    <div class="panel-section">
        <div class="panel-title">
            ENTITIES
            <button id="btn-spawn" class="primary">Spawn</button>
        </div>
        <div id="entity-list"></div>
    </div>

    <div id="log-panel"></div>
</div>
</div>

<!-- Modal for Assumptions -->
<div id="assumptions-modal" class="modal">
<div class="modal-content">
<div class="modal-header">SYSTEM ASSUMPTIONS & MECHANICS</div>
<ul class="assumption-list">
    <li><strong>Performance Optimizations:</strong> Heavy math operations (tanh, exp, atan) replaced with cheaper approximations</li>
    <li><strong>Activity Level:</strong> Uses softstep (smoothstep) approximation instead of tanh</li>
    <li><strong>Signature Computation:</strong> Uses log1p-based approximation for activity boost</li>
    <li><strong>Detection Score:</strong> Uses inverse-square falloff with cheaper log1p signature scaling</li>
    <li><strong>Angular Tracking:</strong> Uses polynomial approximation instead of atan for tracking difficulty</li>
    <li><strong>Clustering:</strong> Spatial hash grid for O(n) average complexity instead of O(n²)</li>
    <li><strong>Distance Caching:</strong> Quantized distance computations reduce redundant calculations</li>
    <li><strong>Debug Modes:</strong> 'Performance' shows minimal info, 'Heavy' shows full granular telemetry</li>
    <li><strong>Relative Range Rings:</strong> Each entity shows detection/weapon range rings relative to its position</li>
    <li><strong>Deterministic:</strong> All outputs are deterministic, no random toggling of debug state</li>
    <li><strong>Weapon System:</strong> Pre-baked weapon stats eliminate runtime division, use only multiplication</li>
    <li><strong>Guided Weapons:</strong> Respect lock quality for hit probability when guidance type is "guided"</li>
</ul>
<button onclick="document.getElementById('assumptions-modal').style.display='none'">Close</button>
</div>
</div>

<div id="import-modal" class="modal">
<div class="modal-content">
<div class="modal-header">IMPORT STATE FROM JSON</div>
<div style="margin-bottom: 10px;">
    <label for="import-file-input">Select JSON file:</label>
    <input type="file" id="import-file-input" accept=".json" style="width: 100%; margin-top: 5px;">
</div>
<div style="display: flex; gap: 10px;">
    <button id="btn-import-confirm" class="primary">Import</button>
    <button onclick="document.getElementById('import-modal').style.display='none'">Cancel</button>
</div>
</div>
</div>

<script>

// =========================================================================
// WEAPON DATABASE
// =========================================================================

const WEAPON_DB = {
    "weapons_test": [
        {
            "id": "pulse_laser_mk1",
            "name": "Pulse Laser Mk1",
            "baseAccuracy": 0.75,
            "effectiveRange_km": 8,
            "trackingSpeed": 0.15,
            "trackingSensitivity": 2.5,
            "guidance": "unguided"
        },
        {
            "id": "pulse_laser_mk2",
            "name": "Pulse Laser Mk2",
            "baseAccuracy": 0.82,
            "effectiveRange_km": 10,
            "trackingSpeed": 0.18,
            "trackingSensitivity": 2.2,
            "guidance": "unguided"
        },
        {
            "id": "railgun_light",
            "name": "Light Railgun",
            "baseAccuracy": 0.88,
            "effectiveRange_km": 25,
            "trackingSpeed": 0.05,
            "trackingSensitivity": 3.0,
            "guidance": "unguided"
        },
        {
            "id": "railgun_heavy",
            "name": "Heavy Railgun",
            "baseAccuracy": 0.92,
            "effectiveRange_km": 40,
            "trackingSpeed": 0.03,
            "trackingSensitivity": 3.5,
            "guidance": "unguided"
        },
        {
            "id": "autocannon_20mm",
            "name": "20mm Autocannon",
            "baseAccuracy": 0.65,
            "effectiveRange_km": 5,
            "trackingSpeed": 0.25,
            "trackingSensitivity": 1.8,
            "guidance": "unguided"
        },
        {
            "id": "autocannon_75mm",
            "name": "75mm Autocannon",
            "baseAccuracy": 0.70,
            "effectiveRange_km": 12,
            "trackingSpeed": 0.12,
            "trackingSensitivity": 2.0,
            "guidance": "unguided"
        },
        {
            "id": "missile_striker",
            "name": "Striker Missile",
            "baseAccuracy": 0.95,
            "effectiveRange_km": 50,
            "trackingSpeed": 0.08,
            "trackingSensitivity": 1.5,
            "guidance": "guided"
        },
        {
            "id": "missile_heavy_torpedo",
            "name": "Heavy Torpedo",
            "baseAccuracy": 0.98,
            "effectiveRange_km": 80,
            "trackingSpeed": 0.04,
            "trackingSensitivity": 2.0,
            "guidance": "guided"
        },
        {
            "id": "beam_laser",
            "name": "Beam Laser",
            "baseAccuracy": 0.90,
            "effectiveRange_km": 18,
            "trackingSpeed": 0.10,
            "trackingSensitivity": 2.2,
            "guidance": "unguided"
        },
        {
            "id": "plasma_cannon",
            "name": "Plasma Cannon",
            "baseAccuracy": 0.78,
            "effectiveRange_km": 15,
            "trackingSpeed": 0.08,
            "trackingSensitivity": 2.8,
            "guidance": "unguided"
        }
    ]
};

// =========================================================================
// WEAPON BAKING SYSTEM
// =========================================================================

const BAKED_WEAPONS = {};

function bakeWeaponStats(config) {
    const rangeKm = config.effectiveRange_km;
    const invRangeSq = 1.0 / ((rangeKm * 1000) ** 2);
    const invTracking = 1.0 / Math.max(0.0001, config.trackingSpeed);
    const trackingSensitivity = 0.5 * (config.trackingSensitivity || 2.0);
    
    return {
        id: config.id,
        name: config.name,
        baseAccuracy: config.baseAccuracy,
        invRangeSq: invRangeSq,
        invTracking: invTracking,
        trackingSensitivity: trackingSensitivity,
        maxRangeM: rangeKm * 1000,
        guidance: config.guidance || "unguided",
        originalConfig: config
    };
}

function computeHitProbOptimized(bakedWeapon, distSq, targetAngVel, lockQuality) {
    const distFactor = 1.0 / (1.0 + (distSq * bakedWeapon.invRangeSq));
    
    let trackingFactor = 1.0;
    
    if (bakedWeapon.guidance === "guided" && lockQuality !== undefined && lockQuality > 0.5) {
        trackingFactor = 0.95 + (lockQuality * 0.05);
    } else {
        const angRatio = targetAngVel * bakedWeapon.invTracking;
        let penalty = Math.max(0, angRatio - 1.0) * bakedWeapon.trackingSensitivity;
        if (penalty > 1.0) penalty = 1.0;
        trackingFactor = 1.0 - (penalty * penalty);
    }
    
    return bakedWeapon.baseAccuracy * distFactor * trackingFactor;
}

function initializeWeaponDatabase() {
    WEAPON_DB.weapons_test.forEach(w => {
        BAKED_WEAPONS[w.id] = bakeWeaponStats(w);
    });
    log(`Baked ${Object.keys(BAKED_WEAPONS).length} weapons`, 'INFO', 'SYS');
}

// =========================================================================
// PERFORMANCE COUNTERS
// =========================================================================

const PERF_COUNTERS = {
    activityComputations: 0,
    signatureComputations: 0,
    detectionScoreComputations: 0,
    lockStateComputations: 0,
    clusterOperations: 0,
    distanceComputations: 0,
    angularVelocityComputations: 0,
    
    tanhCalls: 0,
    expCalls: 0,
    atanCalls: 0,
    sqrtCalls: 0,
    
    reset: function() {
        this.activityComputations = 0;
        this.signatureComputations = 0;
        this.detectionScoreComputations = 0;
        this.lockStateComputations = 0;
        this.clusterOperations = 0;
        this.distanceComputations = 0;
        this.angularVelocityComputations = 0;
        this.tanhCalls = 0;
        this.expCalls = 0;
        this.atanCalls = 0;
        this.sqrtCalls = 0;
    },
    
    getReport: function() {
        return {
            total_function_calls: this.activityComputations + this.signatureComputations + 
                                 this.detectionScoreComputations + this.lockStateComputations + 
                                 this.clusterOperations + this.distanceComputations + 
                                 this.angularVelocityComputations,
            expensive_ops: this.tanhCalls + this.expCalls + this.atanCalls,
            breakdown: {
                activity: this.activityComputations,
                signature: this.signatureComputations,
                detection: this.detectionScoreComputations,
                lockState: this.lockStateComputations,
                clustering: this.clusterOperations,
                distance: this.distanceComputations,
                angularVel: this.angularVelocityComputations
            },
            expensive_breakdown: {
                tanh: this.tanhCalls,
                exp: this.expCalls,
                atan: this.atanCalls,
                sqrt: this.sqrtCalls
            }
        };
    }
};

// =========================================================================
// FAST MATH APPROXIMATIONS
// =========================================================================

const FastMath = {
    softstep: function(x) {
        if (x <= 0) return 0;
        if (x >= 1) return 1;
        return x * x * (3 - 2 * x);
    },
    
    log1pNormalized: function(x, k) {
        const xk = x * k;
        return xk / (1 + xk);
    },
    
    inverseSquareFalloff: function(distanceKm, effectiveRange) {
        const ratio = distanceKm / effectiveRange;
        return 1 / (1 + ratio * ratio);
    },
    
    fastAtanAccurate: function(x) {
        if (x < -1) {
            return -Math.PI/2 - this.fastAtanAccurate(1/x);
        }
        if (x > 1) {
            return Math.PI/2 - this.fastAtanAccurate(1/x);
        }
        const x2 = x * x;
        return x * (0.99997726 + x2 * (-0.33262347 + x2 * (0.19354346 + x2 * (-0.11643287 + x2 * 0.05265332))));
    },
    
    fastSigmoid: function(x) {
        if (x < -4) return 0;
        if (x > 4) return 1;
        const normalized = (x + 4) / 8;
        return this.softstep(normalized);
    }
};

// =========================================================================
// SPATIAL HASH GRID
// =========================================================================

class SpatialHashGrid {
    constructor(cellSize) {
        this.cellSize = cellSize || 5000;
        this.grid = new Map();
    }
    
    clear() {
        this.grid.clear();
    }
    
    _hashKey(x, y) {
        const cx = Math.floor(x / this.cellSize);
        const cy = Math.floor(y / this.cellSize);
        return `${cx},${cy}`;
    }
    
    insert(entity, x, y) {
        const key = this._hashKey(x, y);
        if (!this.grid.has(key)) {
            this.grid.set(key, []);
        }
        this.grid.get(key).push(entity);
    }
    
    queryRadius(x, y, radius) {
        const results = [];
        const cellRadius = Math.ceil(radius / this.cellSize);
        const cx = Math.floor(x / this.cellSize);
        const cy = Math.floor(y / this.cellSize);
        
        for (let dx = -cellRadius; dx <= cellRadius; dx++) {
            for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                const key = `${cx + dx},${cy + dy}`;
                const cell = this.grid.get(key);
                if (cell) {
                    results.push(...cell);
                }
            }
        }
        return results;
    }
}

// =========================================================================
// DISTANCE CACHE
// =========================================================================

const DistanceCache = {
    _cache: new Map(),
    _quantizeStep: 10,
    
    _quantizePos(x, y) {
        const qx = Math.floor(x / this._quantizeStep) * this._quantizeStep;
        const qy = Math.floor(y / this._quantizeStep) * this._quantizeStep;
        return `${qx},${qy}`;
    },
    
    get(x1, y1, x2, y2) {
        const key = `${this._quantizePos(x1, y1)}_${this._quantizePos(x2, y2)}`;
        return this._cache.get(key);
    },
    
    set(x1, y1, x2, y2, distance) {
        const key = `${this._quantizePos(x1, y1)}_${this._quantizePos(x2, y2)}`;
        this._cache.set(key, distance);
        
        if (this._cache.size > 1000) {
            const firstKey = this._cache.keys().next().value;
            this._cache.delete(firstKey);
        }
    },
    
    clear() {
        this._cache.clear();
    }
};

// =========================================================================
// IMPROVED SENSOR MATH
// =========================================================================

const ImprovedSensorMath = {
    clamp: function(val, min, max) {
        return Math.max(min, Math.min(max, val));
    }
};

ImprovedSensorMath.SHIP_PROFILES = {
    "Interceptor": {
        baseSignature: 15,
        activityGain: 1.8,
        size: "frigate",
        description: "Fast, low signature craft"
    },
    "Corvette": {
        baseSignature: 18,
        activityGain: 1.6,
        size: "frigate",
        description: "Small patrol vessel"
    },
    "Light Frigate": {
        baseSignature: 25,
        activityGain: 1.7,
        size: "frigate",
        description: "Basic combat vessel"
    },
    "Heavy Frigate": {
        baseSignature: 35,
        activityGain: 2.0,
        size: "frigate",
        description: "Reinforced multi-role frigate"
    },
    "Destroyer": {
        baseSignature: 45,
        activityGain: 2.1,
        size: "cruiser",
        description: "Line combat vessel"
    },
    "Light Cruiser": {
        baseSignature: 55,
        activityGain: 2.2,
        size: "cruiser",
        description: "Multi-role capital ship"
    },
    "Battlecruiser": {
        baseSignature: 65,
        activityGain: 2.3,
        size: "cruiser",
        description: "Heavy firepower platform"
    },
    "Carrier": {
        baseSignature: 90,
        activityGain: 2.5,
        size: "capital",
        description: "Fighter operations, always visible"
    },
    "Dreadnought": {
        baseSignature: 85,
        activityGain: 2.4,
        size: "capital",
        description: "Maximum firepower, impossible to hide"
    },
    "Command Ship": {
        baseSignature: 75,
        activityGain: 2.6,
        size: "capital",
        description: "C&C vessel with high sensor emissions"
    }
};

ImprovedSensorMath.loadCustomProfiles = function() {
    try {
        const stored = localStorage.getItem('customShipProfiles');
        if (stored) {
            const custom = JSON.parse(stored);
            Object.assign(ImprovedSensorMath.SHIP_PROFILES, custom);
        }
    } catch (e) {
        console.error('Failed to load custom profiles:', e);
    }
};

ImprovedSensorMath.saveCustomProfile = function(name, profile) {
    try {
        const stored = localStorage.getItem('customShipProfiles');
        const custom = stored ? JSON.parse(stored) : {};
        custom[name] = profile;
        localStorage.setItem('customShipProfiles', JSON.stringify(custom));
        ImprovedSensorMath.SHIP_PROFILES[name] = profile;
        return true;
    } catch (e) {
        console.error('Failed to save custom profile:', e);
        return false;
    }
};

ImprovedSensorMath.getShipProfile = function(shipName){
    if(!shipName) shipName = '';
    const normalize = s => String(s).replace(/[\s\-_]/g,'').toLowerCase();
    if(!ImprovedSensorMath._profileLookup){
        ImprovedSensorMath._profileLookup = {};
        Object.keys(ImprovedSensorMath.SHIP_PROFILES).forEach(k=>{
            ImprovedSensorMath._profileLookup[ normalize(k) ] = ImprovedSensorMath.SHIP_PROFILES[k];
        });
    }
    const found = ImprovedSensorMath._profileLookup[ normalize(shipName) ];
    if(found) return found;
    if(ImprovedSensorMath.SHIP_PROFILES[shipName]) return ImprovedSensorMath.SHIP_PROFILES[shipName];
    return { baseSignature: 20, activityGain: 1.5, size: "frigate", description: "Default profile" };
};

ImprovedSensorMath.getAvailableShipTypes = function() {
    return Object.keys(ImprovedSensorMath.SHIP_PROFILES);
};

ImprovedSensorMath.computeActivityLevel = function(velocityRatio, weaponsFiring, radarActive) {
    PERF_COUNTERS.activityComputations++;
    
    velocityRatio = Math.max(0, Math.min(1, Number(velocityRatio) || 0));
    const velWeight = CONFIG.get('MATH_VEL_WEIGHT');
    const weaponWeight = CONFIG.get('MATH_WEAPON_WEIGHT');
    const radarWeight = CONFIG.get('MATH_RADAR_WEIGHT');
    const sensitivity = CONFIG.get('MATH_SENSITIVITY');
    
    let rawActivity = velocityRatio * velWeight;
    if (weaponsFiring) rawActivity += weaponWeight;
    if (radarActive) rawActivity += radarWeight;
    
    const centered = sensitivity * (rawActivity - 1.0);
    const normalized = (centered + 3) / 6;
    return FastMath.softstep(Math.max(0, Math.min(1, normalized)));
};

ImprovedSensorMath.computeSignature = function(shipType, activityLevel) {
    PERF_COUNTERS.signatureComputations++;
    
    const profile = ImprovedSensorMath.getShipProfile(shipType);
    const baseSig = Math.max(0, Number(profile.baseSignature) || 0);
    const gain = Math.max(0, Number(profile.activityGain) || 0);
    activityLevel = ImprovedSensorMath.clamp(Number(activityLevel) || 0, 0.0, 1.0);
    const k = CONFIG.get('MATH_SIG_K');
    
    const activityBoostNormalized = FastMath.log1pNormalized(activityLevel, k);
    const activityBoost = activityBoostNormalized * gain;
    return Math.max(0, baseSig * (1 + activityBoost));
};

ImprovedSensorMath.computeDetectionScore = function(signature, sensorPower, distanceM, opts = {}) {
    PERF_COUNTERS.detectionScoreComputations++;
    
    signature = Math.max(0, Number(signature) || 0);
    sensorPower = Math.max(0, Number(sensorPower) || 0);
    distanceM = Number(distanceM);
    if (!isFinite(distanceM) || distanceM <= 0) distanceM = 1;
    if (signature <= 0 || sensorPower <= 0) return 0;
    
    const distanceKm = distanceM / 1000;
    const effectiveRange = ('effectiveRange' in opts) ? Number(opts.effectiveRange) : CONFIG.get('MATH_EFFECTIVE_RANGE');
    const peakScore = ('peakScore' in opts) ? Number(opts.peakScore) : CONFIG.get('MATH_PEAK_SCORE');
    const referenceStrength = ('referenceStrength' in opts) ? Number(opts.referenceStrength) : CONFIG.get('MATH_REF_STRENGTH');
    
    const strength = (signature * sensorPower) / referenceStrength;
    const strengthFactor = FastMath.log1pNormalized(strength, 1.0);
    const distanceFactor = FastMath.inverseSquareFalloff(distanceKm, effectiveRange);
    
    return peakScore * strengthFactor * distanceFactor;
};

ImprovedSensorMath.isDetected = function(detectionScore, detectionThreshold) {
    detectionScore = Number(detectionScore) || 0;
    detectionThreshold = (typeof detectionThreshold === 'number') ? detectionThreshold : 15;
    detectionThreshold = Math.max(0, Number(detectionThreshold) || 0);
    return detectionScore >= detectionThreshold;
};

ImprovedSensorMath.computeDetectionRange = function(signature, sensorPower, threshold, opts = {}) {
    signature = Math.max(0, Number(signature) || 0);
    sensorPower = Math.max(0, Number(sensorPower) || 0);
    threshold = Math.max(0, Number(threshold) || 0);
    if (threshold <= 0) return Infinity;
    if (signature <= 0 || sensorPower <= 0) return 0;
    
    const peakScore = ('peakScore' in opts) ? Number(opts.peakScore) : CONFIG.get('MATH_PEAK_SCORE');
    const effectiveRange = ('effectiveRange' in opts) ? Number(opts.effectiveRange) : CONFIG.get('MATH_EFFECTIVE_RANGE');
    const referenceStrength = ('referenceStrength' in opts) ? Number(opts.referenceStrength) : CONFIG.get('MATH_REF_STRENGTH');
    
    const strength = (signature * sensorPower) / referenceStrength;
    const strengthFactor = FastMath.log1pNormalized(strength, 1.0);
    
    const maxScore = peakScore * strengthFactor;
    if (maxScore < threshold) return 0;
    
    const ratio = threshold / maxScore;
    if (ratio >= 1) return 0;
    
    const sqrtArg = (maxScore / threshold) - 1;
    if (sqrtArg < 0) return 0;
    
    PERF_COUNTERS.sqrtCalls++;
    const rangeKm = effectiveRange * Math.sqrt(sqrtArg);
    return Math.max(0, rangeKm * 1000);
};

ImprovedSensorMath.computeAngularVelocity = function(target_pos, target_vel, observer_pos, observer_vel) {
    PERF_COUNTERS.angularVelocityComputations++;
    
    const tx = (target_pos.x || 0) - (observer_pos.x || 0);
    const ty = (target_pos.y || 0) - (observer_pos.y || 0);
    const tz = ((target_pos.z || 0) - (observer_pos.z || 0));

    PERF_COUNTERS.sqrtCalls++;
    const dist = Math.sqrt(tx*tx + ty*ty + tz*tz);
    const minDist = 0.0001;

    if (!isFinite(dist) || dist < minDist) return [0.0, 0.0];

    const dir_x = tx / dist;
    const dir_y = ty / dist;
    const dir_z = tz / dist;

    const rvx = (target_vel.x || 0) - (observer_vel.x || 0);
    const rvy = (target_vel.y || 0) - (observer_vel.y || 0);
    const rvz = ((target_vel.z || 0) - (observer_vel.z || 0));

    const dot = rvx * dir_x + rvy * dir_y + rvz * dir_z;
    const lin_x = dot * dir_x;
    const lin_y = dot * dir_y;
    const lin_z = dot * dir_z;

    const trans_x = rvx - lin_x;
    const trans_y = rvy - lin_y;
    const trans_z = rvz - lin_z;

    PERF_COUNTERS.sqrtCalls++;
    const transversal_speed = Math.sqrt(trans_x*trans_x + trans_y*trans_y + trans_z*trans_z);
    const angular_velocity = transversal_speed / dist;

    if (!isFinite(angular_velocity) || !isFinite(transversal_speed)) return [0.0, 0.0];

    return [angular_velocity, transversal_speed];
};

ImprovedSensorMath.computeLockState = function(detectionScore, angularVelocity, trackingTime, trackingSpeed) {
    PERF_COUNTERS.lockStateComputations++;
    
    trackingSpeed = Math.max(0.01, trackingSpeed || 0.1);
    const minDetection = CONFIG.get('MATH_MIN_DETECTION');
    const fullLockDetection = CONFIG.get('MATH_FULL_LOCK_DETECT');
    const optimalTrackTime = CONFIG.get('MATH_OPTIMAL_TRACK_TIME');
    const maxAngularPenalty = CONFIG.get('MATH_MAX_ANG_PENALTY');

    const detectionFactor = FastMath.fastSigmoid(0.1 * (detectionScore - fullLockDetection));
    
    const angularRatio = angularVelocity / trackingSpeed;
    const atanResult = FastMath.fastAtanAccurate(angularRatio);
    const trackingDifficulty = atanResult / (Math.PI / 2);
    
    const trackingFactor = 1 - (trackingDifficulty * maxAngularPenalty);
    const timeFactor = FastMath.fastSigmoid(3 * (trackingTime / optimalTrackTime - 0.5));
    
    const lockQuality = detectionFactor * trackingFactor * timeFactor;

    let state = "ACQUIRING";
    if (lockQuality > 0.75 && detectionScore > fullLockDetection) {
        state = "LOCKED";
    } else if (lockQuality >= 0.25) {
        state = "TRACKING";
    } else if (lockQuality < 0.01) {
        state = "NONE";
    }
    return { state: state, quality: lockQuality };
};

ImprovedSensorMath.computeHitProbability = function(baseAccuracy, distanceM, targetAngularVel, trackingSpeed) {
    baseAccuracy = Math.max(0, Math.min(1, baseAccuracy));
    trackingSpeed = Math.max(0.01, trackingSpeed || 0.05);
    const distanceKm = Math.max(0, distanceM) / 1000;
    const effectiveWeaponRange = CONFIG.get('MATH_WEAPON_RANGE');
    const trackingSteepness = CONFIG.get('MATH_TRACKING_STEEP');
    
    const distanceFactor = FastMath.inverseSquareFalloff(distanceKm, effectiveWeaponRange);
    const angularRatio = targetAngularVel / trackingSpeed;
    const trackingFactor = 1 - FastMath.fastSigmoid(trackingSteepness * (angularRatio - 1));
    
    return baseAccuracy * distanceFactor * trackingFactor;
};

ImprovedSensorMath.computeWeaponRange = function(baseAccuracy, hitThreshold) {
    hitThreshold = ImprovedSensorMath.clamp(hitThreshold || 0.5, 0.01, 1);
    baseAccuracy = ImprovedSensorMath.clamp(baseAccuracy, 0.01, 1);
    const ratio = hitThreshold / baseAccuracy;
    if (ratio >= 1) return 0;
    
    const effectiveRange = 15;
    const sqrtArg = (1 / ratio) - 1;
    if (sqrtArg < 0) return 0;
    
    PERF_COUNTERS.sqrtCalls++;
    const distKm = effectiveRange * Math.sqrt(sqrtArg);
    return Math.max(0, distKm * 1000);
};

ImprovedSensorMath.clusterTargets = function(targets, clusterRadius){
    PERF_COUNTERS.clusterOperations++;
    
    clusterRadius = Math.max(100, clusterRadius || 5000);
    const COMPRESSION_FACTOR = 0.85;
    
    if (targets.length === 0) return [];
    
    const grid = new SpatialHashGrid(clusterRadius);
    targets.forEach((t, idx) => {
        grid.insert(idx, t.x || 0, t.y || 0);
    });
    
    const clusters = [];
    const claimed = new Array(targets.length).fill(false);

    for(let i=0; i<targets.length; i++){
        if(claimed[i]) continue;
        
        const t = targets[i];
        const cluster = {
            members: [i],
            total_sig: (t.signature || 0),
            weighted_pos_x: (t.x || 0) * (t.signature || 1),
            weighted_pos_y: (t.y || 0) * (t.signature || 1),
            weighted_pos_z: (t.z || 0) * (t.signature || 1)
        };
        claimed[i] = true;

        const nearbyIndices = grid.queryRadius(t.x || 0, t.y || 0, clusterRadius);
        
        for(let j of nearbyIndices){
            if(i===j || claimed[j]) continue;
            const other = targets[j];
            const dx = (t.x||0) - (other.x||0);
            const dy = (t.y||0) - (other.y||0);
            const dz = (t.z||0) - (other.z||0);
            
            PERF_COUNTERS.sqrtCalls++;
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
            
            if(dist <= clusterRadius){
                cluster.members.push(j);
                cluster.total_sig += (other.signature || 0);
                cluster.weighted_pos_x += (other.x||0) * (other.signature || 1);
                cluster.weighted_pos_y += (other.y||0) * (other.signature || 1);
                cluster.weighted_pos_z += (other.z||0) * (other.signature || 1);
                claimed[j] = true;
            }
        }

        const count = cluster.members.length;
        const display_sig = cluster.total_sig * (count>1 ? COMPRESSION_FACTOR : 1.0);
        let pos_x = 0, pos_y = 0, pos_z = 0;
        if(cluster.total_sig > 0){
            pos_x = cluster.weighted_pos_x / cluster.total_sig;
            pos_y = cluster.weighted_pos_y / cluster.total_sig;
            pos_z = cluster.weighted_pos_z / cluster.total_sig;
        }
        clusters.push({
            x: pos_x,
            y: pos_y,
            z: pos_z,
            signature: display_sig,
            count: count,
            members: cluster.members.map(idx => targets[idx])
        });
    }
    return clusters;
};

// =========================================================================
// STABLE ID GENERATOR
// =========================================================================
const IDGenerator = {
    _counter: 1,
    next: function() {
        return this._counter++;
    },
    reset: function() {
        this._counter = 1;
    }
};

// =========================================================================
// DOM ELEMENT CACHE
// =========================================================================
const DOM = {
    canvas: null,
    ctx: null,
    hudPlayerPos: null,
    hudPlayerState: null,
    hudContacts: null,
    hudLockOutgoing: null,
    hudLockIncoming: null,
    hudSelection: null,
    hudWeaponName: null,
    hudHitProb: null,
    threatWarning: null,
    rangeLegend: null,
    
    entityControlPanel: null,
    entityControlId: null,
    entityShipType: null,
    entityProfileDesc: null,
    entityTeam: null,
    entityWeapon: null,
    entityVel: null,
    entityVelNum: null,
    entityHead: null,
    entityHeadNum: null,
    entityWeapons: null,
    entitySensorPower: null,
    entitySensorPowerNum: null,
    entityEcm: null,
    entityEcmNum: null,
    
    infoSig: null,
    infoActivity: null,
    infoDetection: null,
    
    weaponInfoPanel: null,
    weaponNameDisplay: null,
    weaponAccuracyDisplay: null,
    weaponRangeDisplay: null,
    weaponTrackingDisplay: null,
    weaponGuidanceDisplay: null,
    weaponSensitivityDisplay: null,
    weaponDistFactor: null,
    weaponTrackFactor: null,
    weaponHitProbDisplay: null,
    
    entityList: null,
    logPanel: null,
    zoomSlider: null,
    zoomValNum: null,
    debugToggle: null,
    debugModeSelect: null,
    showRangeRings: null,
    showRangeLegend: null,
    
    init: function() {
        this.canvas = document.getElementById('main-canvas');
        this.ctx = this.canvas.getContext('2d');
        
        this.hudPlayerPos = document.getElementById('hud-player-pos');
        this.hudPlayerState = document.getElementById('hud-player-state');
        this.hudContacts = document.getElementById('hud-contacts');
        this.hudLockOutgoing = document.getElementById('hud-lock-outgoing');
        this.hudLockIncoming = document.getElementById('hud-lock-incoming');
        this.hudSelection = document.getElementById('hud-selection');
        this.hudWeaponName = document.getElementById('hud-weapon-name');
        this.hudHitProb = document.getElementById('hud-hit-prob');
        this.threatWarning = document.getElementById('threat-warning');
        this.rangeLegend = document.getElementById('range-legend');
        
        this.entityControlPanel = document.getElementById('entity-control-panel');
        this.entityControlId = document.getElementById('entity-control-id');
        this.entityShipType = document.getElementById('entity-ship-type');
        this.entityProfileDesc = document.getElementById('entity-profile-description');
        this.entityTeam = document.getElementById('entity-team');
        this.entityWeapon = document.getElementById('entity-weapon');
        this.entityVel = document.getElementById('entity-vel');
        this.entityVelNum = document.getElementById('entity-vel-num');
        this.entityHead = document.getElementById('entity-head');
        this.entityHeadNum = document.getElementById('entity-head-num');
        this.entityWeapons = document.getElementById('entity-weapons');
        this.entitySensorPower = document.getElementById('entity-sensor-power');
        this.entitySensorPowerNum = document.getElementById('entity-sensor-power-num');
        this.entityEcm = document.getElementById('entity-ecm');
        this.entityEcmNum = document.getElementById('entity-ecm-num');
        
        this.infoSig = document.getElementById('info-sig');
        this.infoActivity = document.getElementById('info-activity');
        this.infoDetection = document.getElementById('info-detection');
        
        this.weaponInfoPanel = document.getElementById('weapon-info-panel');
        this.weaponNameDisplay = document.getElementById('weapon-name-display');
        this.weaponAccuracyDisplay = document.getElementById('weapon-accuracy-display');
        this.weaponRangeDisplay = document.getElementById('weapon-range-display');
        this.weaponTrackingDisplay = document.getElementById('weapon-tracking-display');
        this.weaponGuidanceDisplay = document.getElementById('weapon-guidance-display');
        this.weaponSensitivityDisplay = document.getElementById('weapon-sensitivity-display');
        this.weaponDistFactor = document.getElementById('weapon-dist-factor');
        this.weaponTrackFactor = document.getElementById('weapon-track-factor');
        this.weaponHitProbDisplay = document.getElementById('weapon-hit-prob-display');
        
        this.entityList = document.getElementById('entity-list');
        this.logPanel = document.getElementById('log-panel');
        this.zoomSlider = document.getElementById('zoom-slider');
        this.zoomValNum = document.getElementById('zoom-val-num');
        this.debugToggle = document.getElementById('debug-toggle');
        this.debugModeSelect = document.getElementById('debug-mode-select');
        this.showRangeRings = document.getElementById('show-range-rings');
        this.showRangeLegend = document.getElementById('show-range-legend');
    }
};

// =========================================================================
// APP CONFIGURATION
// =========================================================================

const CONFIG = {
    SENSOR_STRENGTH: { name: 'Sensor Power', val: 70, min: 10, max: 200, step: 10, cat: 'sys', unit: 'score' },
    DETECT_THRESH: { name: 'Detect Threshold', val: 15, min: 5, max: 50, step: 5, cat: 'sys', unit: 'score' },
    TRACKING_SPEED: { name: 'Tracking Speed', val: 0.2, min: 0.01, max: 0.5, step: 0.01, cat: 'sys', unit: 'rad/s' },
    ECM_SCALE: { name: 'ECM Scale', val: 0.05, min: 0.01, max: 0.2, step: 0.01, cat: 'sys', unit: 'multiplier' },
    WEAPON_ACCURACY: { name: 'Base Accuracy', val: 0.85, min: 0.1, max: 1.0, step: 0.05, cat: 'sys', unit: 'probability' },
    WEAPON_TRACKING: { name: 'Weapon Tracking', val: 0.05, min: 0.01, max: 0.2, step: 0.01, cat: 'sys', unit: 'rad/s' },
    CLUSTER_RAD: { name: 'Cluster Radius', val: 5000, min: 1000, max: 20000, step: 500, cat: 'sys', unit: 'meters' },    
    MATH_VEL_WEIGHT: { name: 'Velocity Weight', val: 1.0, min: 0.1, max: 3.0, step: 0.1, cat: 'math', unit: 'multiplier' },
    MATH_WEAPON_WEIGHT: { name: 'Weapon Weight', val: 0.8, min: 0.1, max: 2.0, step: 0.1, cat: 'math', unit: 'multiplier' },
    MATH_RADAR_WEIGHT: { name: 'Radar Weight', val: 0.5, min: 0.1, max: 2.0, step: 0.1, cat: 'math', unit: 'multiplier' },
    MATH_SENSITIVITY: { name: 'Activity Sensitivity', val: 1.5, min: 0.5, max: 4.0, step: 0.1, cat: 'math', unit: 'multiplier' },
    MATH_SIG_K: { name: 'Signature Curve (k)', val: 9.0, min: 1.0, max: 20.0, step: 0.5, cat: 'math', unit: 'dimensionless' },
    MATH_EFFECTIVE_RANGE: { name: 'Effective Range', val: 30, min: 10, max: 200, step: 5, cat: 'math', unit: 'km' },
    MATH_PEAK_SCORE: { name: 'Peak Score', val: 140, min: 50, max: 500, step: 10, cat: 'math', unit: 'score' },
    MATH_REF_STRENGTH: { name: 'Reference Strength', val: 100, min: 10, max: 500, step: 10, cat: 'math', unit: 'score' },
    MATH_MIN_DETECTION: { name: 'Min Detection Lock', val: 10, min: 5, max: 50, step: 5, cat: 'math', unit: 'score' },
    MATH_FULL_LOCK_DETECT: { name: 'Full Lock Detection', val: 30, min: 30, max: 100, step: 5, cat: 'math', unit: 'score' },
    MATH_OPTIMAL_TRACK_TIME: { name: 'Optimal Track Time', val: 2.0, min: 0.5, max: 10.0, step: 0.5, cat: 'math', unit: 'seconds' },
    MATH_MAX_ANG_PENALTY: { name: 'Max Angular Penalty', val: 0.3, min: 0.1, max: 1.0, step: 0.05, cat: 'math', unit: 'fraction' },
    MATH_WEAPON_RANGE: { name: 'Weapon Range', val: 20, min: 5, max: 100, step: 5, cat: 'math', unit: 'km' },
    MATH_TRACKING_STEEP: { name: 'Tracking Steepness', val: 2.0, min: 0.5, max: 5.0, step: 0.1, cat: 'math', unit: 'dimensionless' },
    
    get: function(key) {
        const cfg = this[key];
        if (!cfg) return 0;
        return ImprovedSensorMath.clamp(cfg.val, cfg.min, cfg.max);
    }
};

// =========================================================================
// UNIVERSAL ENTITY CLASS
// =========================================================================

class Entity {
    constructor(id, x, y, shipType, role = 'bot') {
        this.id = id;
        this.role = role;
        this.shipType = shipType || "Heavy Frigate";
        this.weaponId = "pulse_laser_mk1";
        
        this.x = x;
        this.y = y;
        this.z = 0;
        
        this.speed = 0;
        this.heading = 0;
        this.vx = 0;
        this.vy = 0;
        this.vz = 0;
        
        this.weaponsFiring = false;
        this.radarActive = true;
        
        this.sensorMode = 'Active';
        this.sensorPower = 1.0;
        
        this.signature = 0;
        this.activityLevel = 0;
        this.detected = false;
        this.detectionScore = 0;
        this.trackingQuality = 0;
        this.angularVelocity = 0;
        this.hitProbability = 0;
        
        this.team = 'player';
        this.ecm = 0;
        
        this._incomingTrackingTime = 0;
        this._prevIncomingStatus = 'NONE';
        
        this._weaponDistFactor = 0;
        this._weaponTrackFactor = 0;
    }
    
    getSizeClass() {
        return ImprovedSensorMath.getShipProfile(this.shipType).size;
    }
    
    updateVelocity() {
        this.vx = Math.cos(this.heading) * this.speed;
        this.vy = Math.sin(this.heading) * this.speed;
        this.vz = 0;
    }
    
    updateSignature() {
        const velocityRatio = this.speed / 200;
        this.activityLevel = ImprovedSensorMath.computeActivityLevel(
            velocityRatio,
            this.weaponsFiring,
            this.radarActive
        );
        this.signature = ImprovedSensorMath.computeSignature(this.shipType, this.activityLevel);
    }
    
    update(dt) {
        this.updateVelocity();
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.updateSignature();
    }
}

// =========================================================================
// APP STATE
// =========================================================================

const STATE = {
    entities: [],
    outgoingLock: { targetId: null, trackingTime: 0, status: 'NONE', quality: 0, prevStatus: 'NONE' },
    incomingLocks: [],
    selectedId: null,
    playing: true,
    zoom: 0.15,
    panX: 0,
    panY: 0,
    defaultShipType: "Heavy Frigate",
    defaultTeam: "player",
    defaultWeapon: "pulse_laser_mk1",
    debugMode: 'off',
    showRangeRings: true,
    showRangeLegend: true,
    playerBeingLocked: false,
    _hudUpdateCounter: 0,
    _hudUpdateInterval: 3,
    _last_dt: 0.016,
    
    getPlayer: function() {
        return this.entities.find(e => e.role === 'player');
    },
    
    getBots: function() {
        return this.entities.filter(e => e.role === 'bot');
    }
};

// =========================================================================
// KEYBOARD STATE
// =========================================================================

const keyState = {
    w: false, a: false, s: false, d: false,
    W: false, A: false, S: false, D: false,
    ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false
};

// =========================================================================
// MATH HELPERS
// =========================================================================

function dist(a, b) {
    PERF_COUNTERS.distanceComputations++;
    
    const cached = DistanceCache.get(a.x, a.y, b.x, b.y);
    if (cached !== undefined) {
        return cached;
    }
    
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    PERF_COUNTERS.sqrtCalls++;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    DistanceCache.set(a.x, a.y, b.x, b.y, distance);
    
    return distance;
}

function rad(deg) { return deg * Math.PI / 180; }
function deg(rad) { return rad * 180 / Math.PI; }

// =========================================================================
// POSSESSION SYSTEM
// =========================================================================

function transferPossession(targetEntity) {
    const currentPlayer = STATE.getPlayer();
    
    if (currentPlayer) {
        currentPlayer.role = 'bot';
    }
    
    targetEntity.role = 'player';
    STATE.selectedId = targetEntity.id;
    
    updateEntityControlUI();
    refreshEntityList();
    
    log(`Possession transferred to Entity ${targetEntity.id} (${targetEntity.shipType})`, 'INFO', 'SYS');
}

// =========================================================================
// LOCK UPDATE FUNCTION
// =========================================================================

function updateLocks(){
    const player = STATE.getPlayer();
    if (!player) return;
    
    const out = STATE.outgoingLock;
    const target = out.targetId ? STATE.entities.find(e => e.id === out.targetId) : null;
    
    if(target && target.detected && player){
        out.trackingTime += STATE._last_dt || 0.016;
        const targetVel = { x: Math.cos(target.heading)*target.speed, y: Math.sin(target.heading)*target.speed, z: 0 };
        const playerVel = { x: player.vx, y: player.vy, z: 0 };
        const angRes = ImprovedSensorMath.computeAngularVelocity({x: target.x, y: target.y, z: 0}, targetVel, {x: player.x, y: player.y, z: 0}, playerVel);
        const angVel = angRes[0];
        const lockResult = ImprovedSensorMath.computeLockState(target.detectionScore, angVel, out.trackingTime, CONFIG.get('TRACKING_SPEED'));
        out.status = lockResult.state;
        out.quality = lockResult.quality;
    } else {
        out.trackingTime = Math.max(0, out.trackingTime - (STATE._last_dt || 0.016) * 2);
        out.status = "NONE";
        out.quality = 0;
    }
    if(out.status !== out.prevStatus){
        log(`OutgoingLock: ${out.status} [${Math.round(out.quality*100)}%]`, 'LOCK', 'PLR');
        out.prevStatus = out.status;
    }

    STATE.incomingLocks = [];
    STATE.entities.forEach(src=>{
        if (src.team === player.team || src.role === 'player') return;
        
        const sourceSensorMultiplier = (src.sensorPower !== undefined) ? Number(src.sensorPower) : 1.0;
        const sourceSensorPower = CONFIG.get('SENSOR_STRENGTH') * sourceSensorMultiplier;
        const distance = dist(src, player);
        const detectionScoreOnPlayer = ImprovedSensorMath.computeDetectionScore(player.signature, sourceSensorPower, distance);

        if(detectionScoreOnPlayer >= CONFIG.get('DETECT_THRESH')){
            const srcVel = { x: Math.cos(src.heading)*src.speed, y: Math.sin(src.heading)*src.speed, z: 0 };
            const playerVel = { x: player.vx, y: player.vy, z: 0 };
            const angRes = ImprovedSensorMath.computeAngularVelocity({x: player.x, y: player.y, z: 0}, playerVel, {x: src.x, y: src.y, z: 0}, srcVel);
            const angVelSrc = angRes[0];

            src._incomingTrackingTime = Math.max(0, (src._incomingTrackingTime || 0) + (STATE._last_dt || 0.016));
            const lockOnPlayer = ImprovedSensorMath.computeLockState(detectionScoreOnPlayer, angVelSrc, src._incomingTrackingTime, CONFIG.get('TRACKING_SPEED'));

            STATE.incomingLocks.push({
                sourceId: src.id,
                status: lockOnPlayer.state,
                quality: lockOnPlayer.quality,
                detectionScore: detectionScoreOnPlayer
            });

            if(src._prevIncomingStatus !== lockOnPlayer.state){
                log(`IncomingLockFrom: ${src.id} => ${lockOnPlayer.state} [${Math.round(lockOnPlayer.quality*100)}%]`, 'LOCK', 'SYS');
                src._prevIncomingStatus = lockOnPlayer.state;
            }
        } else {
            src._incomingTrackingTime = Math.max(0, (src._incomingTrackingTime || 0) - (STATE._last_dt || 0.016)*2);
            if(src._incomingTrackingTime <= 0){
                src._incomingTrackingTime = 0;
                if(src._prevIncomingStatus && src._prevIncomingStatus !== 'NONE'){
                    log(`IncomingLockFrom: ${src.id} LOST`, 'LOCK', 'SYS');
                }
                src._prevIncomingStatus = 'NONE';
            }
        }
    });

    STATE.playerBeingLocked = STATE.incomingLocks.some(l => l.status === 'LOCKED');
}

// =========================================================================
// MOVEMENT CONTROLS
// =========================================================================

function applyMovementControls(entity, dt) {
    const moveSpeed = 50;
    const turnSpeed = 1.5;
    
    let moveX = 0;
    let moveY = 0;
    let turn = 0;
    
    if (keyState.w || keyState.W || keyState.ArrowUp) moveY -= 1;
    if (keyState.s || keyState.S || keyState.ArrowDown) moveY += 1;
    if (keyState.a || keyState.A || keyState.ArrowLeft) turn -= 1;
    if (keyState.d || keyState.D || keyState.ArrowRight) turn += 1;
    
    if (turn !== 0) {
        entity.heading += turn * turnSpeed * dt;
        while (entity.heading < 0) entity.heading += Math.PI * 2;
        while (entity.heading >= Math.PI * 2) entity.heading -= Math.PI * 2;
    }
    
    if (moveY !== 0) {
        entity.speed = Math.max(0, Math.min(200, entity.speed + moveY * moveSpeed * dt));
    }
}

// =========================================================================
// SIMULATION LOOP
// =========================================================================

let lastTime = 0;

function loop(time) {
    requestAnimationFrame(loop);

    const dt = Math.min((time - lastTime) / 1000, 0.1);
    lastTime = time;

    if (!STATE.playing) return;

    STATE._last_dt = dt;

    const player = STATE.getPlayer();
    
    if (player) {
        applyMovementControls(player, dt);
        player.update(dt);
    }

    STATE.entities.forEach(entity => {
        if (entity.role === 'player') return;
        
        const vx = Math.cos(entity.heading) * entity.speed;
        const vy = Math.sin(entity.heading) * entity.speed;
        
        entity.x += vx * dt;
        entity.y += vy * dt;

        const velocityRatio = entity.speed / 200;
        entity.activityLevel = ImprovedSensorMath.computeActivityLevel(
            velocityRatio,
            entity.weaponsFiring,
            entity.radarActive
        );

        entity.signature = ImprovedSensorMath.computeSignature(entity.shipType, entity.activityLevel);

        if (player) {
            const distance = dist(entity, player);
            const effectiveSensorPower = CONFIG.get('SENSOR_STRENGTH') * player.sensorPower;
            entity.detectionScore = ImprovedSensorMath.computeDetectionScore(
                entity.signature,
                effectiveSensorPower,
                distance
            );
            entity.detected = ImprovedSensorMath.isDetected(entity.detectionScore, CONFIG.get('DETECT_THRESH'));

            if (entity.detected) {
                const targetVel = { x: vx, y: vy, z: 0 };
                const playerVel = { x: player.vx, y: player.vy, z: 0 };
                const playerPos = { x: player.x, y: player.y, z: 0 };
                const tgtPos = { x: entity.x, y: entity.y, z: 0 };

                const angRes = ImprovedSensorMath.computeAngularVelocity(tgtPos, targetVel, playerPos, playerVel);
                entity.angularVelocity = angRes[0];
                
                const angVelWithECM = entity.angularVelocity * (1 + entity.ecm * CONFIG.get('ECM_SCALE'));
                
                const weapon = BAKED_WEAPONS[player.weaponId];
                if (weapon && player.weaponsFiring) {
                    const dx = entity.x - player.x;
                    const dy = entity.y - player.y;
                    const distSq = dx*dx + dy*dy;
                    
                    const lockQuality = (entity.id === STATE.outgoingLock.targetId) ? STATE.outgoingLock.quality : 0;
                    
                    entity.hitProbability = computeHitProbOptimized(weapon, distSq, angVelWithECM, lockQuality);
                    
                    entity._weaponDistFactor = 1.0 / (1.0 + (distSq * weapon.invRangeSq));
                    const angRatio = angVelWithECM * weapon.invTracking;
                    let penalty = Math.max(0, angRatio - 1.0) * weapon.trackingSensitivity;
                    if (penalty > 1.0) penalty = 1.0;
                    entity._weaponTrackFactor = 1.0 - (penalty * penalty);
                } else {
                    entity.hitProbability = 0;
                    entity._weaponDistFactor = 0;
                    entity._weaponTrackFactor = 0;
                }
            } else {
                entity.angularVelocity = 0;
                entity.hitProbability = 0;
                entity._weaponDistFactor = 0;
                entity._weaponTrackFactor = 0;
            }
        }
    });

    updateLocks();
    render();
    
    const hudInterval = STATE.debugMode === 'heavy' ? 1 : 3;
    STATE._hudUpdateCounter++;
    if (STATE._hudUpdateCounter >= hudInterval) {
        STATE._hudUpdateCounter = 0;
        updateHUD();
    }
    
    updateEntityControlInfo();
    updateWeaponInfo();
}

// =========================================================================
// RENDERING
// =========================================================================

let canvasW, canvasH;

function resizeCanvas() {
    const parent = DOM.canvas.parentElement;
    const dpr = window.devicePixelRatio || 1;
    DOM.canvas.width = parent.clientWidth * dpr;
    DOM.canvas.height = parent.clientHeight * dpr;
    DOM.canvas.style.width = parent.clientWidth + 'px';
    DOM.canvas.style.height = parent.clientHeight + 'px';
    canvasW = parent.clientWidth;
    canvasH = parent.clientHeight;
    DOM.ctx.scale(dpr, dpr);
}

function render() {
    window.DEBUG_LABEL_STACK = [];

    const ctx = DOM.ctx;
    const player = STATE.getPlayer();
    
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    const dpr = window.devicePixelRatio || 1;
    ctx.scale(dpr, dpr);
    
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, canvasW, canvasH);

    const cx = canvasW / 2;
    const cy = canvasH / 2;

    ctx.save();
    
    const playerOffsetX = player ? -player.x : 0;
    const playerOffsetY = player ? -player.y : 0;
    
    ctx.translate(cx + STATE.panX, cy + STATE.panY);
    ctx.scale(STATE.zoom, STATE.zoom);
    ctx.translate(playerOffsetX, playerOffsetY);

    const lw = 1 / STATE.zoom;
    ctx.lineWidth = lw;
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';

    const viewLeft = (-(cx + STATE.panX) / STATE.zoom) - playerOffsetX;
    const viewTop = (-(cy + STATE.panY) / STATE.zoom) - playerOffsetY;
    const viewRight = ((canvasW - (cx + STATE.panX)) / STATE.zoom) - playerOffsetX;
    const viewBottom = ((canvasH - (cy + STATE.panY)) / STATE.zoom) - playerOffsetY;

    const gridSize = 1000;
    const startX = Math.floor(viewLeft / gridSize) * gridSize;
    const startY = Math.floor(viewTop / gridSize) * gridSize;

    ctx.beginPath();
    for (let x = startX; x < viewRight; x += gridSize) {
        ctx.moveTo(x, viewTop); ctx.lineTo(x, viewBottom);
    }
    for (let y = startY; y < viewBottom; y += gridSize) {
        ctx.moveTo(viewLeft, y); ctx.lineTo(viewRight, y);
    }
    ctx.stroke();

    if (STATE.showRangeRings) {
        renderEntityRangeRings(ctx);
    }

    const teamClusters = {};
    STATE.entities.forEach(e => {
        if (!teamClusters[e.team]) teamClusters[e.team] = [];
        teamClusters[e.team].push(e);
    });

    const clusterRadius = 2000;
    const allClusters = [];
    
    Object.keys(teamClusters).forEach(team => {
        const entities = teamClusters[team];
        if (entities.length < 2) return;
        
        const claimed = new Set();
        
        entities.forEach((e, i) => {
            if (claimed.has(i)) return;
            
            const cluster = {
                team: team,
                centerX: e.x,
                centerY: e.y,
                count: 1,
                members: [i]
            };
            claimed.add(i);
            
            entities.forEach((other, j) => {
                if (i === j || claimed.has(j)) return;
                const dx = e.x - other.x;
                const dy = e.y - other.y;
                const d = Math.sqrt(dx * dx + dy * dy);
                
                if (d <= clusterRadius) {
                    cluster.count++;
                    cluster.members.push(j);
                    claimed.add(j);
                    cluster.centerX = (cluster.centerX * (cluster.count - 1) + other.x) / cluster.count;
                    cluster.centerY = (cluster.centerY * (cluster.count - 1) + other.y) / cluster.count;
                }
            });
            
            if (cluster.count > 1) {
                allClusters.push(cluster);
            }
        });
    });

    STATE.entities.forEach(e => {
        const isPlayer = e.role === 'player';
        const isAlly = e.team === player?.team;
        const isSelected = e.id === STATE.selectedId;
        
        ctx.save();
        ctx.translate(e.x, e.y);
        ctx.rotate(e.heading);
        
        if (isPlayer) {
            ctx.fillStyle = '#3fb950';
            ctx.strokeStyle = '#fff';
        } else if (isAlly) {
            ctx.fillStyle = e.detected ? 'rgba(0, 217, 255, 0.6)' : 'rgba(0, 217, 255, 0.3)';
            ctx.strokeStyle = '#00d9ff';
        } else {
            ctx.fillStyle = e.detected ? 'rgba(255, 69, 0, 0.6)' : 'rgba(255, 69, 0, 0.3)';
            ctx.strokeStyle = '#ff4500';
        }
        
        ctx.lineWidth = isSelected ? 3 / STATE.zoom : 2 / STATE.zoom;
        
        const sizeMap = { frigate: isPlayer ? 30 : 24, cruiser: isPlayer ? 50 : 40, capital: isPlayer ? 80 : 70 };
        const size = sizeMap[e.getSizeClass()] || (isPlayer ? 30 : 24);
        
        ctx.beginPath();
        ctx.moveTo(size, 0);
        ctx.lineTo(-size * 0.6, size * 0.5);
        ctx.lineTo(-size * 0.4, 0);
        ctx.lineTo(-size * 0.6, -size * 0.5);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.restore();
        
        if (STATE.debugMode === 'heavy' && e.detected && !isPlayer) {
            const label = buildDebugLabel(e);
            queueDebugLabel(e.x, e.y - (size + 15), label);
        }
    });

    ctx.font = `${Math.floor(16 / STATE.zoom)}px monospace`;
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
    ctx.lineWidth = 3 / STATE.zoom;
    
    allClusters.forEach(cluster => {
        const text = `[${cluster.count}]`;
        const metrics = ctx.measureText(text);
        const textWidth = metrics.width;
        const textHeight = 16 / STATE.zoom;
        
        ctx.strokeText(text, cluster.centerX - textWidth / 2, cluster.centerY - textHeight - 10 / STATE.zoom);
        ctx.fillText(text, cluster.centerX - textWidth / 2, cluster.centerY - textHeight - 10 / STATE.zoom);
    });

    if (STATE.outgoingLock.status !== 'NONE' && STATE.outgoingLock.targetId) {
        const target = STATE.entities.find(e => e.id === STATE.outgoingLock.targetId);
        if (target && player) {
            ctx.strokeStyle = STATE.outgoingLock.status === 'LOCKED' ? '#d29922' : 'rgba(210, 153, 34, 0.5)';
            ctx.lineWidth = 2 / STATE.zoom;
            ctx.setLineDash([10 / STATE.zoom, 10 / STATE.zoom]);
            ctx.beginPath();
            ctx.moveTo(player.x, player.y);
            ctx.lineTo(target.x, target.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }

    ctx.restore();
    
    renderDebugLabels(ctx, cx, cy);
}

function renderEntityRangeRings(ctx) {
    const player = STATE.getPlayer();
    if (!player) return;
    
    const playerSensorPower = CONFIG.get('SENSOR_STRENGTH') * player.sensorPower;
    const threshold = CONFIG.get('DETECT_THRESH');
    
    const weapon = BAKED_WEAPONS[player.weaponId];
    const weaponRange = weapon ? weapon.maxRangeM : 0;
    
    const entitiesToRing = [];
    
    entitiesToRing.push({
        entity: player,
        color: 'rgba(63, 185, 80, 0.25)',
        rings: [1000, 5000, 10000]
    });
    
    const maxRingedTargets = STATE.debugMode === 'heavy' ? 10 : 3;
    const detectedTargets = STATE.entities.filter(e => e.detected && e.role !== 'player').slice(0, maxRingedTargets);
    
    detectedTargets.forEach(e => {
        const isAlly = e.team === player.team;
        entitiesToRing.push({
            entity: e,
            color: isAlly ? 'rgba(0, 217, 255, 0.2)' : 'rgba(255, 69, 0, 0.2)',
            rings: [1000, 5000, 10000]
        });
    });
    
    if (STATE.debugMode === 'heavy') {
        const detectionRange = ImprovedSensorMath.computeDetectionRange(1, playerSensorPower, threshold);
        if (isFinite(detectionRange) && detectionRange > 0) {
            ctx.strokeStyle = 'rgba(63, 185, 80, 0.4)';
            ctx.lineWidth = 3 / STATE.zoom;
            ctx.setLineDash([5 / STATE.zoom, 5 / STATE.zoom]);
            ctx.beginPath();
            ctx.arc(player.x, player.y, detectionRange, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
    
    if (STATE.debugMode === 'heavy' && weaponRange > 0) {
        ctx.strokeStyle = 'rgba(210, 153, 34, 0.4)';
        ctx.lineWidth = 3 / STATE.zoom;
        ctx.setLineDash([3 / STATE.zoom, 7 / STATE.zoom]);
        ctx.beginPath();
        ctx.arc(player.x, player.y, weaponRange, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    entitiesToRing.forEach(item => {
        const e = item.entity;
        ctx.strokeStyle = item.color;
        ctx.lineWidth = 2 / STATE.zoom;
        
        item.rings.forEach(r => {
            ctx.beginPath();
            ctx.arc(e.x, e.y, r, 0, Math.PI * 2);
            ctx.stroke();
        });
    });
}

function buildDebugLabel(entity) {
    const player = STATE.getPlayer();
    if (!player) return '';
    
    const distKm = (dist(entity, player) / 1000).toFixed(1);
    const sig = Math.round(entity.signature);
    const det = Math.round(entity.detectionScore);
    const spd = Math.round(entity.speed);
    const lock = entity.id === STATE.outgoingLock.targetId ? `[${STATE.outgoingLock.status}]` : '';
    const hitProb = (entity.hitProbability * 100).toFixed(0);
    
    return `ID:${entity.id} ${entity.shipType.substring(0,8)} | ${distKm}km | S:${sig} D:${det} V:${spd}m/s H:${hitProb}% ${lock}`.trim();
}

function queueDebugLabel(x, y, text) {
    if (!window.DEBUG_LABEL_STACK) window.DEBUG_LABEL_STACK = [];
    window.DEBUG_LABEL_STACK.push({ x, y, text });
}

function renderDebugLabels(ctx, cx, cy) {
    if (!window.DEBUG_LABEL_STACK || window.DEBUG_LABEL_STACK.length === 0) return;
    
    const player = STATE.getPlayer();
    
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    const dpr = window.devicePixelRatio || 1;
    ctx.scale(dpr, dpr);
    
    ctx.font = '10px monospace';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
    ctx.lineWidth = 3;
    
    window.DEBUG_LABEL_STACK.forEach(label => {
        const playerOffsetX = player ? -player.x : 0;
        const playerOffsetY = player ? -player.y : 0;
        
        const screenX = cx + STATE.panX + (label.x + playerOffsetX) * STATE.zoom;
        const screenY = cy + STATE.panY + (label.y + playerOffsetY) * STATE.zoom;
        
        ctx.strokeText(label.text, screenX, screenY);
        ctx.fillText(label.text, screenX, screenY);
    });
    
    ctx.restore();
}

// =========================================================================
// HUD UPDATE
// =========================================================================

function updateHUD() {
    const player = STATE.getPlayer();
    
    if (player && DOM.hudPlayerPos) {
        const px = (player.x / 1000).toFixed(1);
        const py = (player.y / 1000).toFixed(1);
        DOM.hudPlayerPos.innerText = `${px}km, ${py}km`;
    }

    if (DOM.hudContacts) {
        DOM.hudContacts.innerText = STATE.entities.length - 1;
    }

    if (DOM.hudLockOutgoing) {
        const out = STATE.outgoingLock;
        const quality = Math.round(out.quality * 100);
        DOM.hudLockOutgoing.innerText = `${out.status} (${quality}%)`;
        DOM.hudLockOutgoing.style.color = out.status === 'LOCKED' ? '#d29922' : '#58a6ff';
    }

    if (DOM.hudLockIncoming) {
        const incoming = STATE.incomingLocks.filter(l => l.status !== 'NONE');
        if (incoming.length > 0) {
            const locked = incoming.filter(l => l.status === 'LOCKED').length;
            const tracking = incoming.filter(l => l.status === 'TRACKING' || l.status === 'ACQUIRING').length;
            DOM.hudLockIncoming.innerText = `${locked} LOCKED, ${tracking} TRACKING`;
            DOM.hudLockIncoming.style.color = locked > 0 ? '#f85149' : '#d29922';
        } else {
            DOM.hudLockIncoming.innerText = 'NONE';
            DOM.hudLockIncoming.style.color = '#3fb950';
        }
    }

    if (player && DOM.hudWeaponName) {
        const weapon = BAKED_WEAPONS[player.weaponId];
        DOM.hudWeaponName.innerText = weapon ? weapon.name : 'NONE';
    }

    if (player && DOM.hudHitProb) {
        const target = STATE.outgoingLock.targetId ? STATE.entities.find(e => e.id === STATE.outgoingLock.targetId) : null;
        if (target && target.detected && player.weaponsFiring) {
            const hitProb = (target.hitProbability * 100).toFixed(1);
            DOM.hudHitProb.innerText = `${hitProb}%`;
            DOM.hudHitProb.style.color = target.hitProbability > 0.5 ? '#3fb950' : '#d29922';
        } else {
            DOM.hudHitProb.innerText = '0%';
            DOM.hudHitProb.style.color = '#8b949e';
        }
    }

    if (DOM.threatWarning) {
        DOM.threatWarning.classList.toggle('visible', !!STATE.playerBeingLocked);
        DOM.threatWarning.setAttribute('aria-hidden', STATE.playerBeingLocked ? 'false' : 'true');
    }
    
    if (DOM.rangeLegend) {
        DOM.rangeLegend.classList.toggle('shift-up', !!STATE.playerBeingLocked);
    }
    
    if (DOM.hudSelection && STATE.selectedId) {
        const e = STATE.entities.find(x => x.id === STATE.selectedId);
        if (e && player) {
            const distKm = (dist(e, player)/1000).toFixed(1);
            DOM.hudSelection.innerText = `Selected: ${e.shipType} (${distKm}km)`;
        }
    } else if (DOM.hudSelection) {
        DOM.hudSelection.innerText = '';
    }
    
    refreshEntityList();
}

function updateWeaponInfo() {
    const entity = STATE.entities.find(e => e.id === STATE.selectedId);
    const player = STATE.getPlayer();
    
    if (!entity || !DOM.weaponInfoPanel) return;
    
    const weapon = BAKED_WEAPONS[entity.weaponId];
    
    if (weapon) {
        DOM.weaponInfoPanel.style.display = 'block';
        DOM.weaponNameDisplay.textContent = weapon.name;
        DOM.weaponAccuracyDisplay.textContent = (weapon.baseAccuracy * 100).toFixed(0) + '%';
        DOM.weaponRangeDisplay.textContent = (weapon.maxRangeM / 1000).toFixed(1) + ' km';
        DOM.weaponTrackingDisplay.textContent = weapon.originalConfig.trackingSpeed.toFixed(3) + ' rad/s';
        DOM.weaponGuidanceDisplay.textContent = weapon.guidance.toUpperCase();
        DOM.weaponSensitivityDisplay.textContent = weapon.originalConfig.trackingSensitivity.toFixed(1);
        
        if (entity.role === 'player') {
            const target = STATE.outgoingLock.targetId ? STATE.entities.find(e => e.id === STATE.outgoingLock.targetId) : null;
            if (target && target.detected && entity.weaponsFiring) {
                DOM.weaponDistFactor.textContent = (target._weaponDistFactor * 100).toFixed(1) + '%';
                DOM.weaponTrackFactor.textContent = (target._weaponTrackFactor * 100).toFixed(1) + '%';
                DOM.weaponHitProbDisplay.textContent = (target.hitProbability * 100).toFixed(1) + '%';
                DOM.weaponHitProbDisplay.style.color = target.hitProbability > 0.5 ? 'var(--success)' : 'var(--warning)';
            } else {
                DOM.weaponDistFactor.textContent = '0%';
                DOM.weaponTrackFactor.textContent = '0%';
                DOM.weaponHitProbDisplay.textContent = '0%';
                DOM.weaponHitProbDisplay.style.color = 'var(--text-dim)';
            }
        } else {
            DOM.weaponDistFactor.textContent = '-';
            DOM.weaponTrackFactor.textContent = '-';
            DOM.weaponHitProbDisplay.textContent = '-';
        }
    } else {
        DOM.weaponInfoPanel.style.display = 'none';
    }
}

// =========================================================================
// INPUT HANDLERS
// =========================================================================

function setupInputHandlers() {
    let isDragging = false;
    let dragStartX = 0, dragStartY = 0;
    let lastClickTime = 0;
    
    DOM.canvas.addEventListener('mousedown', (e) => {
        const currentTime = Date.now();
        const isDoubleClick = currentTime - lastClickTime < 300;
        lastClickTime = currentTime;
        
        if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
            isDragging = true;
            dragStartX = e.clientX - STATE.panX;
            dragStartY = e.clientY - STATE.panY;
            e.preventDefault();
        } else if (e.button === 0) {
            const rect = DOM.canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            
            const cx = canvasW / 2;
            const cy = canvasH / 2;
            const player = STATE.getPlayer();
            const playerOffsetX = player ? -player.x : 0;
            const playerOffsetY = player ? -player.y : 0;
            
            const worldX = ((mx - cx - STATE.panX) / STATE.zoom) - playerOffsetX;
            const worldY = ((my - cy - STATE.panY) / STATE.zoom) - playerOffsetY;
            
            let closestEntity = null;
            let closestDist = Infinity;
            
            STATE.entities.forEach(e => {
                const dx = e.x - worldX;
                const dy = e.y - worldY;
                const d = Math.sqrt(dx*dx + dy*dy);
                if (d < closestDist && d < 500) {
                    closestDist = d;
                    closestEntity = e;
                }
            });
            
            if (closestEntity) {
                if (isDoubleClick) {
                    transferPossession(closestEntity);
                } else {
                    selectEntity(closestEntity.id);
                }
            }
        }
    });
    
    DOM.canvas.addEventListener('mousemove', (e) => {
        if (isDragging) {
            STATE.panX = e.clientX - dragStartX;
            STATE.panY = e.clientY - dragStartY;
        }
    });
    
    DOM.canvas.addEventListener('mouseup', () => {
        isDragging = false;
    });
    
    DOM.canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
        STATE.zoom = ImprovedSensorMath.clamp(STATE.zoom * zoomFactor, 0.05, 5);
        DOM.zoomSlider.value = STATE.zoom;
        DOM.zoomValNum.value = STATE.zoom.toFixed(2);
    });
    
    createDualInputSync(DOM.zoomSlider, DOM.zoomValNum, (val) => {
        STATE.zoom = val;
    });
    
    DOM.debugToggle.addEventListener('change', (e) => {
        if (e.target.checked && STATE.debugMode === 'off') {
            STATE.debugMode = 'perf';
            DOM.debugModeSelect.value = 'perf';
        } else if (!e.target.checked) {
            STATE.debugMode = 'off';
            DOM.debugModeSelect.value = 'off';
        }
        document.getElementById('btn-debug').classList.toggle('mode-active', e.target.checked);
    });
    
    DOM.debugModeSelect.addEventListener('change', (e) => {
        STATE.debugMode = e.target.value;
        DOM.debugToggle.checked = STATE.debugMode !== 'off';
        document.getElementById('btn-debug').classList.toggle('mode-active', STATE.debugMode !== 'off');
    });
    
    DOM.showRangeRings.addEventListener('change', (e) => {
        STATE.showRangeRings = e.target.checked;
    });
    
    DOM.showRangeLegend.addEventListener('change', (e) => {
        STATE.showRangeLegend = e.target.checked;
        if (DOM.rangeLegend) {
            DOM.rangeLegend.classList.toggle('visible', e.target.checked);
        }
    });
    
    document.getElementById('btn-play').addEventListener('click', () => {
        STATE.playing = !STATE.playing;
        document.getElementById('btn-play').innerText = STATE.playing ? 'Pause' : 'Play';
    });
    
    document.getElementById('btn-step').addEventListener('click', () => {
        if (!STATE.playing) {
            loop(performance.now());
        }
    });
    
    document.getElementById('btn-reset').addEventListener('click', resetSim);
    document.getElementById('btn-spawn').addEventListener('click', spawnEntity);
    document.getElementById('btn-debug').addEventListener('click', () => {
        DOM.debugToggle.checked = !DOM.debugToggle.checked;
        DOM.debugToggle.dispatchEvent(new Event('change'));
    });
    
    document.getElementById('btn-test-preset').addEventListener('click', () => {
        document.getElementById('import-modal').style.display = 'flex';
    });
    
    document.getElementById('btn-assumptions').addEventListener('click', () => {
        document.getElementById('assumptions-modal').style.display = 'flex';
    });
    
    document.getElementById('btn-export').addEventListener('click', exportState);
    document.getElementById('btn-run-tests').addEventListener('click', runPerfTests);
    document.getElementById('btn-import-confirm').addEventListener('click', importState);
    document.getElementById('btn-save-profile').addEventListener('click', saveCustomProfile);
    
    window.addEventListener('keydown', (e) => {
        if (e.key in keyState) {
            keyState[e.key] = true;
            e.preventDefault();
        }
    });
    
    window.addEventListener('keyup', (e) => {
        if (e.key in keyState) {
            keyState[e.key] = false;
        }
    });
    
    setupEntityControlHandlers();
}

function setupEntityControlHandlers() {
    createDualInputSync(DOM.entityVel, DOM.entityVelNum, (val) => {
        const entity = STATE.entities.find(e => e.id === STATE.selectedId);
        if (entity) {
            entity.speed = val;
        }
    });
    
    createDualInputSync(DOM.entityHead, DOM.entityHeadNum, (val) => {
        const entity = STATE.entities.find(e => e.id === STATE.selectedId);
        if (entity) {
            entity.heading = rad(val);
        }
    });
    
    DOM.entityWeapons.addEventListener('change', (e) => {
        const entity = STATE.entities.find(x => x.id === STATE.selectedId);
        if (entity) {
            entity.weaponsFiring = e.target.checked;
        }
    });
    
    DOM.entityWeapon.addEventListener('change', (e) => {
        const entity = STATE.entities.find(x => x.id === STATE.selectedId);
        if (entity) {
            entity.weaponId = e.target.value;
            const weapon = BAKED_WEAPONS[e.target.value];
            log(`Entity ${entity.id} weapon changed to ${weapon ? weapon.name : 'Unknown'}`, 'INFO', entity.role === 'player' ? 'PLR' : 'TGT');
            updateWeaponInfo();
        }
    });
    
    document.getElementById('btn-sensor-active').addEventListener('click', () => {
        const entity = STATE.entities.find(x => x.id === STATE.selectedId);
        if (entity) {
            entity.sensorMode = 'Active';
            updateSensorModeButtons();
        }
    });
    
    document.getElementById('btn-sensor-passive').addEventListener('click', () => {
        const entity = STATE.entities.find(x => x.id === STATE.selectedId);
        if (entity) {
            entity.sensorMode = 'Passive';
            updateSensorModeButtons();
        }
    });
    
    createDualInputSync(DOM.entitySensorPower, DOM.entitySensorPowerNum, (val) => {
        const entity = STATE.entities.find(x => x.id === STATE.selectedId);
        if (entity) {
            entity.sensorPower = val;
        }
    });
    
    createDualInputSync(DOM.entityEcm, DOM.entityEcmNum, (val) => {
        const entity = STATE.entities.find(x => x.id === STATE.selectedId);
        if (entity) {
            entity.ecm = val;
        }
    });
    
    DOM.entityShipType.addEventListener('change', (e) => {
        const entity = STATE.entities.find(x => x.id === STATE.selectedId);
        if (entity) {
            entity.shipType = e.target.value;
            const profile = ImprovedSensorMath.getShipProfile(e.target.value);
            DOM.entityProfileDesc.textContent = profile.description;
            log(`Entity ${entity.id} ship type changed to ${e.target.value}`, 'INFO', entity.role === 'player' ? 'PLR' : 'TGT');
        }
    });
    
    DOM.entityTeam.addEventListener('change', (e) => {
        const entity = STATE.entities.find(x => x.id === STATE.selectedId);
        if (entity) {
            entity.team = e.target.value;
            log(`Entity ${entity.id} team changed to ${e.target.value}`, 'INFO', entity.role === 'player' ? 'PLR' : 'TGT');
            refreshEntityList();
        }
    });
    
    document.getElementById('default-ship-profile').addEventListener('change', (e) => {
        STATE.defaultShipType = e.target.value;
        const profile = ImprovedSensorMath.getShipProfile(e.target.value);
        document.getElementById('profile-description').textContent = profile.description;
    });
    
    document.getElementById('default-team').addEventListener('change', (e) => {
        STATE.defaultTeam = e.target.value;
    });
    
    document.getElementById('default-weapon').addEventListener('change', (e) => {
        STATE.defaultWeapon = e.target.value;
    });
}

function updateSensorModeButtons() {
    const entity = STATE.entities.find(x => x.id === STATE.selectedId);
    const active = document.getElementById('btn-sensor-active');
    const passive = document.getElementById('btn-sensor-passive');
    
    if (entity && entity.sensorMode === 'Active') {
        active.classList.add('mode-active');
        passive.classList.remove('mode-active');
    } else {
        active.classList.remove('mode-active');
        passive.classList.add('mode-active');
    }
}

function createDualInputSync(sliderElem, numberElem, callback) {
    const sync = (val) => {
        val = parseFloat(val);
        sliderElem.value = val;
        numberElem.value = val;
        if (callback) callback(val);
    };
    
    sliderElem.addEventListener('input', (e) => sync(e.target.value));
    numberElem.addEventListener('input', (e) => sync(e.target.value));
}

function saveCustomProfile() {
    const name = document.getElementById('custom-profile-name').value.trim();
    const sig = parseFloat(document.getElementById('custom-profile-sig').value);
    const gain = parseFloat(document.getElementById('custom-profile-gain').value);
    const size = document.getElementById('custom-profile-size').value;
    const desc = document.getElementById('custom-profile-desc').value.trim();
    
    if (!name) {
        alert('Please enter a profile name');
        return;
    }
    
    const profile = {
        baseSignature: sig,
        activityGain: gain,
        size: size,
        description: desc || 'Custom profile'
    };
    
    if (ImprovedSensorMath.saveCustomProfile(name, profile)) {
        log(`Custom profile "${name}" saved`, 'INFO', 'SYS');
        populateShipSelects();
        document.getElementById('custom-profile-name').value = '';
        document.getElementById('custom-profile-sig').value = '20';
        document.getElementById('custom-profile-gain').value = '1.5';
        document.getElementById('custom-profile-desc').value = '';
    } else {
        alert('Failed to save profile');
    }
}

// =========================================================================
// UI INITIALIZATION
// =========================================================================

function populateConfigControls() {
    const containers = {
        'sys': document.getElementById('params-detection-container'),
        'math': document.getElementById('params-math-container')
    };
    
    const trackingContainer = document.getElementById('params-tracking-container');
    const weaponContainer = document.getElementById('params-weapon-container');
    
    Object.keys(CONFIG).forEach(key => {
        if (key === 'get') return;
        
        const cfg = CONFIG[key];
        let container;
        
        if (key.includes('TRACKING') || key.includes('LOCK') || key.includes('ECM')) {
            container = trackingContainer;
        } else if (key.includes('WEAPON') || key.includes('ACCURACY')) {
            container = weaponContainer;
        } else if (cfg.cat === 'sys' && !key.includes('CLUSTER')) {
            container = containers['sys'];
        } else {
            container = containers['math'];
        }
        
        if (!container) return;
        
        const group = document.createElement('div');
        group.className = 'control-group';
        
        const label = document.createElement('label');
        const unitText = cfg.unit ? ` (${cfg.unit})` : '';
        label.innerHTML = `<span class="tag tag-sys">SYS</span>${cfg.name}${unitText}`;
        
        const dualInputGroup = document.createElement('div');
        dualInputGroup.className = 'dual-input-group';
        
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = cfg.min;
        slider.max = cfg.max;
        slider.step = cfg.step;
        slider.value = cfg.val;
        
        const numInput = document.createElement('input');
        numInput.type = 'number';
        numInput.min = cfg.min;
        numInput.max = cfg.max;
        numInput.step = cfg.step;
        numInput.value = cfg.val;
        numInput.style.width = '70px';
        
        const sync = (val) => {
            val = parseFloat(val);
            cfg.val = val;
            slider.value = val;
            numInput.value = val;
        };
        
        slider.addEventListener('input', (e) => sync(e.target.value));
        numInput.addEventListener('input', (e) => sync(e.target.value));
        
        dualInputGroup.appendChild(slider);
        dualInputGroup.appendChild(numInput);
        
        group.appendChild(label);
        group.appendChild(dualInputGroup);
        container.appendChild(group);
    });
}

function populateShipSelects() {
    const shipTypes = ImprovedSensorMath.getAvailableShipTypes();
    const selects = [DOM.entityShipType, document.getElementById('default-ship-profile')];
    
    selects.forEach(select => {
        if (!select) return;
        const currentValue = select.value;
        select.innerHTML = '';
        shipTypes.forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = type;
            select.appendChild(option);
        });
        if (currentValue && shipTypes.includes(currentValue)) {
            select.value = currentValue;
        }
    });
    
    if (DOM.entityShipType && !DOM.entityShipType.value) {
        DOM.entityShipType.value = "Heavy Frigate";
        const profile = ImprovedSensorMath.getShipProfile("Heavy Frigate");
        if (DOM.entityProfileDesc) DOM.entityProfileDesc.textContent = profile.description;
    }
    
    const defaultSelect = document.getElementById('default-ship-profile');
    if (defaultSelect && !defaultSelect.value) {
        defaultSelect.value = STATE.defaultShipType;
    }
    const defaultProfile = ImprovedSensorMath.getShipProfile(STATE.defaultShipType);
    document.getElementById('profile-description').textContent = defaultProfile.description;
}

function populateWeaponSelects() {
    const weaponSelects = [DOM.entityWeapon, document.getElementById('default-weapon')];
    
    weaponSelects.forEach(select => {
        if (!select) return;
        const currentValue = select.value;
        select.innerHTML = '';
        
        WEAPON_DB.weapons_test.forEach(w => {
            const option = document.createElement('option');
            option.value = w.id;
            option.textContent = w.name;
            select.appendChild(option);
        });
        
        if (currentValue && BAKED_WEAPONS[currentValue]) {
            select.value = currentValue;
        } else {
            select.value = STATE.defaultWeapon;
        }
    });
}

function initUI() {
    DOM.init();
    
    initializeWeaponDatabase();
    ImprovedSensorMath.loadCustomProfiles();
    
    populateConfigControls();
    populateShipSelects();
    populateWeaponSelects();
    
    setupInputHandlers();
    
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const playerEntity = new Entity(IDGenerator.next(), 0, 0, "Heavy Frigate", 'player');
    playerEntity.weaponId = STATE.defaultWeapon;
    STATE.entities.push(playerEntity);
    STATE.selectedId = playerEntity.id;
    
    updateSensorModeButtons();
    updateEntityControlUI();
    
    log('Enhanced sensor testbed initialized with weapon system!', 'INFO', 'PLR');

    spawnEntity();
    const firstBot = STATE.entities.find(e => e.role === 'bot');
    if (firstBot) {
        firstBot.y = playerEntity.y - 5000;
    }

    loop(0);
}

function updateEntityControlUI() {
    const entity = STATE.entities.find(e => e.id === STATE.selectedId);
    if (!entity) {
        DOM.entityControlPanel.style.display = 'none';
        return;
    }
    
    DOM.entityControlPanel.style.display = 'block';
    DOM.entityControlId.innerText = `ID: ${entity.id} ${entity.role === 'player' ? '[PLAYER]' : ''}`;

    DOM.entityShipType.value = entity.shipType;
    DOM.entityTeam.value = entity.team;
    DOM.entityWeapon.value = entity.weaponId;
    
    DOM.entityVel.value = Math.round(entity.speed);
    DOM.entityVelNum.value = Math.round(entity.speed);
    DOM.entityHead.value = Math.round(deg(entity.heading));
    DOM.entityHeadNum.value = Math.round(deg(entity.heading));

    DOM.entityWeapons.checked = entity.weaponsFiring;
    DOM.entitySensorPower.value = entity.sensorPower.toFixed(1);
    DOM.entitySensorPowerNum.value = entity.sensorPower.toFixed(1);
    DOM.entityEcm.value = entity.ecm.toFixed(1);
    DOM.entityEcmNum.value = entity.ecm.toFixed(1);
    
    const profile = ImprovedSensorMath.getShipProfile(entity.shipType);
    DOM.entityProfileDesc.textContent = profile.description;
    
    updateSensorModeButtons();
}

function updateEntityControlInfo() {
    const entity = STATE.entities.find(e => e.id === STATE.selectedId);
    if (entity && DOM.infoSig) {
        DOM.infoSig.textContent = entity.signature.toFixed(1);
        DOM.infoActivity.textContent = (entity.activityLevel * 100).toFixed(0) + '%';
        
        const player = STATE.getPlayer();
        if (player && entity !== player) {
            try {
                const playerSensorPower = CONFIG.get('SENSOR_STRENGTH') * player.sensorPower;
                const threshold = CONFIG.get('DETECT_THRESH');

                const range_vs_target = ImprovedSensorMath.computeDetectionRange(entity.signature, playerSensorPower, threshold);
                const intrinsicRange = ImprovedSensorMath.computeDetectionRange(1, playerSensorPower, threshold);

                const score = Math.round(entity.detectionScore);
                const rTarget = (range_vs_target / 1000).toFixed(1);
                const rIntr = (intrinsicRange / 1000).toFixed(1);

                DOM.infoDetection.textContent = `${score} (R:${rTarget}km) • INTR:${rIntr}km`;
                DOM.infoDetection.style.color = entity.detectionScore < 50 ? '#d29922' : '#58a6ff';
                
            } catch (e) {
                DOM.infoDetection.textContent = entity.detectionScore.toFixed(1);
            }
        } else {
            DOM.infoDetection.textContent = 'N/A (Player)';
        }
    }
}

function spawnEntity() {
    const id = IDGenerator.next();
    const player = STATE.getPlayer();
    
    let offsetX, offsetY;
    if (STATE.defaultTeam === 'enemy') {
        offsetX = 40000 + (Math.random() - 0.5) * 5000;
        offsetY = (Math.random() - 0.5) * 5000;
    } else {
        offsetX = (Math.random() - 0.5) * 10000;
        offsetY = (Math.random() - 0.5) * 10000 - 5000;
    }
    
    const entity = new Entity(
        id,
        (player ? player.x : 0) + offsetX,
        (player ? player.y : 0) + offsetY,
        STATE.defaultShipType,
        'bot'
    );
    entity.speed = 50 + Math.random() * 50;
    entity.weaponId = STATE.defaultWeapon;
    
    if (STATE.defaultTeam === 'player') {
        entity.heading = 0;
    } else {
        entity.heading = Math.PI;
    }
    
    entity.team = STATE.defaultTeam;
    STATE.entities.push(entity);
    selectEntity(id);
    log(`Spawned ${entity.shipType} (ID: ${id}, Team: ${entity.team})`, 'INFO', STATE.defaultTeam === 'player' ? 'ALLIE' : 'ENEMY');
}

function resetSim() {
    const player = STATE.getPlayer();
    if (player) {
        STATE.entities = [player];
        player.x = 0;
        player.y = 0;
        player.speed = 0;
        player.heading = 0;
        player.weaponsFiring = false;
        player.radarActive = true;
        player.sensorMode = 'Active';
        player.sensorPower = 1.0;
        player.weaponId = STATE.defaultWeapon;
        
        STATE.selectedId = player.id;
        updateEntityControlUI();
    } else {
        STATE.entities = [];
        IDGenerator.reset();
        const newPlayer = new Entity(IDGenerator.next(), 0, 0, "Heavy Frigate", 'player');
        newPlayer.weaponId = STATE.defaultWeapon;
        STATE.entities.push(newPlayer);
        STATE.selectedId = newPlayer.id;
    }
    
    STATE.outgoingLock = { targetId: null, trackingTime: 0, status: 'NONE', quality: 0, prevStatus: 'NONE' };
    STATE.incomingLocks = [];
    DistanceCache.clear();
    
    log('Simulation reset', 'WARN', 'SYS');
    spawnEntity();
}

function selectEntity(id) {
    STATE.selectedId = id;

    if (STATE.outgoingLock.targetId !== id) {
        STATE.outgoingLock.targetId = id;
        STATE.outgoingLock.trackingTime = 0;
        log(`Targeting ID ${id}`, 'INFO', 'SYS');
    }

    updateEntityControlUI();
    updateEntityControlInfo();

    document.querySelectorAll('.entity-item').forEach(el => el.classList.remove('active-entity'));
    const item = document.getElementById(`ent-${id}`);
    if (item) item.classList.add('active-entity');
}

function deleteEntity(id) {
    const entity = STATE.entities.find(e => e.id === id);
    if (!entity) return;
    
    if (entity.role === 'player') {
        log('Cannot delete player entity', 'WARN', 'SYS');
        return;
    }
    
    STATE.entities = STATE.entities.filter(e => e.id !== id);
    
    if (STATE.selectedId === id) {
        const player = STATE.getPlayer();
        STATE.selectedId = player ? player.id : null;
        updateEntityControlUI();
    }
    
    if (STATE.outgoingLock.targetId === id) {
        STATE.outgoingLock.targetId = null;
        STATE.outgoingLock.trackingTime = 0;
        STATE.outgoingLock.status = 'NONE';
    }
    
    refreshEntityList();
    log(`Deleted entity ${id}`, 'INFO', 'SYS');
}

function refreshEntityList() {
    if (!DOM.entityList) return;
    
    const player = STATE.getPlayer();
    
    DOM.entityList.innerHTML = '';
    STATE.entities.forEach(e => {
        if (e.role === 'player') return;
        
        const div = document.createElement('div');
        div.className = `entity-item ${e.id === STATE.selectedId ? 'active-entity' : ''}`;
        div.id = `ent-${e.id}`;

        const isAlly = e.team === (player ? player.team : 'player');
        let tagCls = isAlly ? 'tag-allie' : 'tag-enemy';
        let tagTxt = isAlly ? 'ALLIE' : 'ENEMY';

        const distanceKm = player ? (dist(e, player)/1000).toFixed(1) : '?';
        
        const infoSpan = document.createElement('span');
        infoSpan.innerHTML = `<span class="tag ${tagCls}">${tagTxt}</span> <span>${e.shipType.substring(0, 12)}</span> <span>${distanceKm}km</span>`;
        infoSpan.onclick = () => selectEntity(e.id);
        infoSpan.style.flex = '1';
        infoSpan.style.cursor = 'pointer';
        
        div.appendChild(infoSpan);
        
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'X';
        deleteBtn.className = 'danger delete-btn';
        deleteBtn.onclick = (event) => {
            event.stopPropagation();
            deleteEntity(e.id);
        };
        div.appendChild(deleteBtn);
        
        DOM.entityList.appendChild(div);
    });
}

function exportState() {
    const player = STATE.getPlayer();
    
    const exportData = {
        entities: STATE.entities.map(e => ({
            id: e.id,
            role: e.role,
            x: e.x,
            y: e.y,
            speed: e.speed,
            heading: e.heading,
            shipType: e.shipType,
            weaponId: e.weaponId,
            team: e.team,
            weaponsFiring: e.weaponsFiring,
            ecm: e.ecm,
            sensorPower: e.sensorPower,
            sensorMode: e.sensorMode
        })),
        config: Object.keys(CONFIG).filter(k => k !== 'get').reduce((acc, k) => {
            acc[k] = CONFIG[k].val;
            return acc;
        }, {}),
        zoom: STATE.zoom,
        panX: STATE.panX,
        panY: STATE.panY,
        defaultShipType: STATE.defaultShipType,
        defaultTeam: STATE.defaultTeam,
        defaultWeapon: STATE.defaultWeapon
    };
    
    const json = JSON.stringify(exportData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'sensor_testbed_state.json';
    a.click();
    URL.revokeObjectURL(url);
    
    log('State exported to JSON', 'INFO', 'SYS');
}

function importState() {
    const fileInput = document.getElementById('import-file-input');
    const file = fileInput.files[0];
    
    if (!file) {
        alert('Please select a file');
        return;
    }
    
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const data = JSON.parse(e.target.result);
            
            STATE.entities = [];
            IDGenerator.reset();
            
            if (data.entities && Array.isArray(data.entities)) {
                data.entities.forEach(eData => {
                    const entity = new Entity(
                        IDGenerator.next(),
                        eData.x || 0,
                        eData.y || 0,
                        eData.shipType || "Heavy Frigate",
                        eData.role || 'bot'
                    );
                    entity.speed = eData.speed || 0;
                    entity.heading = eData.heading || 0;
                    entity.team = eData.team || "player";
                    entity.weaponId = eData.weaponId || STATE.defaultWeapon;
                    entity.weaponsFiring = eData.weaponsFiring || false;
                    entity.ecm = eData.ecm || 0;
                    entity.sensorPower = eData.sensorPower || 1.0;
                    entity.sensorMode = eData.sensorMode || 'Active';
                    STATE.entities.push(entity);
                });
            }
            
            const player = STATE.getPlayer();
            if (!player && STATE.entities.length > 0) {
                STATE.entities[0].role = 'player';
            }
            
            if (data.config) {
                Object.keys(data.config).forEach(k => {
                    if (CONFIG[k]) {
                        CONFIG[k].val = data.config[k];
                    }
                });
            }
            
            if (data.zoom !== undefined) {
                STATE.zoom = data.zoom;
                DOM.zoomSlider.value = STATE.zoom;
                DOM.zoomValNum.value = STATE.zoom.toFixed(2);
            }
            if (data.panX !== undefined) STATE.panX = data.panX;
            if (data.panY !== undefined) STATE.panY = data.panY;
            if (data.defaultShipType) STATE.defaultShipType = data.defaultShipType;
            if (data.defaultTeam) STATE.defaultTeam = data.defaultTeam;
            if (data.defaultWeapon) STATE.defaultWeapon = data.defaultWeapon;
            
            const playerEntity = STATE.getPlayer();
            if (playerEntity) {
                STATE.selectedId = playerEntity.id;
                updateEntityControlUI();
            }
            
            document.getElementById('import-modal').style.display = 'none';
            log('State imported from JSON', 'INFO', 'SYS');
            
        } catch (err) {
            console.error('Import error:', err);
            alert('Failed to import state: ' + err.message);
        }
    };
    
    reader.readAsText(file);
}

function log(msg, type='INFO', tag='') {
    if (!DOM.logPanel) return;
    
    const entry = document.createElement('div');
    entry.className = 'log-entry';
    const time = new Date().toISOString().substr(11, 8);
    const tagHtml = tag ? `<span class="log-tag">[${tag}]</span>` : '';
    entry.innerHTML = `<span class="log-time">[${time}]</span>${tagHtml}<span class="log-type-${type}">${type}</span>: ${msg}`;
    DOM.logPanel.prepend(entry);
    if (DOM.logPanel.childNodes.length > 50) DOM.logPanel.lastChild.remove();
}

// =========================================================================
// PERFORMANCE TEST HARNESS
// =========================================================================

function runPerfTests() {
    log('Starting performance test harness...', 'INFO', 'SYS');
    
    const savedEntities = STATE.entities;
    
    PERF_COUNTERS.reset();
    
    const syntheticEntities = [];
    
    for (let i = 0; i < 19; i++) {
        const entity = {
            id: i,
            x: (Math.random() - 0.5) * 100000,
            y: (Math.random() - 0.5) * 100000,
            z: 0,
            speed: Math.random() * 200,
            heading: Math.random() * Math.PI * 2,
            shipType: ["Interceptor", "Corvette", "Light Frigate", "Heavy Frigate", "Destroyer"][Math.floor(Math.random() * 5)],
            weaponsFiring: Math.random() > 0.5,
            radarActive: true,
            signature: 0,
            activityLevel: 0,
            detectionScore: 0,
            team: 'player'
        };
        syntheticEntities.push(entity);
    }
    
    for (let i = 19; i < 39; i++) {
        const entity = {
            id: i,
            x: (Math.random() - 0.5) * 100000,
            y: (Math.random() - 0.5) * 100000,
            z: 0,
            speed: Math.random() * 200,
            heading: Math.random() * Math.PI * 2,
            shipType: ["Interceptor", "Corvette", "Light Frigate", "Heavy Frigate", "Destroyer"][Math.floor(Math.random() * 5)],
            weaponsFiring: Math.random() > 0.5,
            radarActive: true,
            signature: 0,
            activityLevel: 0,
            detectionScore: 0,
            team: 'enemy'
        };
        syntheticEntities.push(entity);
    }
    
    const observer = { x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0 };
    
    const iterations = 10;
    const startTime = performance.now();
    
    for (let iter = 0; iter < iterations; iter++) {
        syntheticEntities.forEach(e => {
            const velocityRatio = e.speed / 200;
            e.activityLevel = ImprovedSensorMath.computeActivityLevel(
                velocityRatio,
                e.weaponsFiring,
                e.radarActive
            );
            
            e.signature = ImprovedSensorMath.computeSignature(e.shipType, e.activityLevel);
            
            const dx = e.x - observer.x;
            const dy = e.y - observer.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            e.detectionScore = ImprovedSensorMath.computeDetectionScore(
                e.signature,
                CONFIG.get('SENSOR_STRENGTH'),
                distance
            );
            
            const vel = { x: Math.cos(e.heading) * e.speed, y: Math.sin(e.heading) * e.speed, z: 0 };
            const pos = { x: e.x, y: e.y, z: e.z };
            ImprovedSensorMath.computeAngularVelocity(pos, vel, observer, { x: 0, y: 0, z: 0 });
        });
        
        ImprovedSensorMath.clusterTargets(syntheticEntities, CONFIG.get('CLUSTER_RAD'));
    }
    
    const endTime = performance.now();
    const totalTime = endTime - startTime;
    
    const report = PERF_COUNTERS.getReport();
    
    log(`PERF TEST COMPLETE: ${iterations} iterations, 39 entities (19 allies + 20 enemies)`, 'INFO', 'SYS');
    log(`Total time: ${totalTime.toFixed(2)}ms (${(totalTime/iterations).toFixed(2)}ms per iteration)`, 'INFO', 'SYS');
    log(`Total function calls: ${report.total_function_calls}`, 'INFO', 'SYS');
    log(`Expensive ops (tanh+exp+atan): ${report.expensive_ops}`, 'INFO', 'SYS');
    log(`Activity computations: ${report.breakdown.activity}`, 'INFO', 'SYS');
    log(`Signature computations: ${report.breakdown.signature}`, 'INFO', 'SYS');
    log(`Detection score computations: ${report.breakdown.detection}`, 'INFO', 'SYS');
    log(`sqrt calls: ${report.expensive_breakdown.sqrt}`, 'INFO', 'SYS');
    
    console.log('=== PERFORMANCE TEST REPORT ===');
    console.log('Total time:', totalTime.toFixed(2), 'ms');
    console.log('Per iteration:', (totalTime/iterations).toFixed(2), 'ms');
    console.log('Per entity per iteration:', (totalTime/(iterations*39)).toFixed(4), 'ms');
    console.log('Function calls:', report);
    
    STATE.entities = savedEntities;
    
    log('Performance test complete. Check console for detailed report.', 'INFO', 'SYS');
}

// Start
initUI();

</script>

</body>
</html>
